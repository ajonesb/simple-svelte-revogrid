import {
  ViewportStore,
  calculateRowHeaderSize,
  getPropertyFromEvent
} from "./chunk-JLLU45HY.js";
import {
  ON_COLUMN_CLICK,
  dispatch
} from "./chunk-5CGUF5AE.js";
import {
  FILTER_PROP,
  isFilterBtn
} from "./chunk-M5ZXGWIN.js";
import {
  CONTENT_SLOT,
  DATA_SLOT,
  FOOTER_SLOT,
  GROUPING_ROW_TYPE,
  GROUP_DEPTH,
  GROUP_EXPANDED,
  GROUP_EXPAND_EVENT,
  HEADER_SLOT,
  PSEUDO_GROUP_COLUMN,
  PSEUDO_GROUP_ITEM_ID,
  PSEUDO_GROUP_ITEM_VALUE,
  baseEach,
  columnTypes,
  cropCellToMax,
  gatherGrouping,
  getCellDataParsed,
  getCellRaw,
  getColumnByProp,
  getColumnSizes,
  getColumnType,
  getColumns,
  getExpanded,
  getGroupingName,
  getParsedGroup,
  getRange,
  getSource,
  isColGrouping,
  isGrouping,
  isGroupingColumn,
  isRowType,
  isSameGroup,
  nextCell,
  reduce,
  rowTypes,
  toInteger,
  viewportDataPartition
} from "./chunk-UGOZVFKQ.js";
import {
  DataStore,
  RESIZE_INTERVAL,
  baseKeys,
  baseProperty,
  calculateDimensionData,
  createStore,
  gatherTrimmedItems,
  getItemByIndex,
  getItemByPosition,
  getPhysical,
  getScrollbarSize,
  getSourceItem,
  getSourceItemVirtualIndexByProp,
  getTag,
  getVisibleSourceItem,
  identity,
  isArray,
  isArrayLike,
  setItems,
  setSourceByPhysicalIndex,
  setSourceByVirtualIndex,
  setStore,
  timeout
} from "./chunk-EKGHPBVA.js";
import {
  baseGetTag,
  debounce,
  isObjectLike
} from "./chunk-TDAIXGLL.js";
import {
  Host,
  createEvent,
  getElement,
  h,
  registerInstance
} from "./chunk-OHTYWBIK.js";
import "./chunk-M2ETFGAV.js";

// node_modules/@revolist/revogrid/dist/esm/column.drag.plugin-CmcURdIJ.js
var recalculateRealSizePlugin = (storeService) => {
  return {
    /**
     * Reacts on changes of count, sizes and originItemSize
     */
    set(k) {
      switch (k) {
        case "count":
        case "sizes":
        case "originItemSize": {
          let realSize = 0;
          const count = storeService.store.get("count");
          for (let i = 0; i < count; i++) {
            realSize += storeService.store.get("sizes")[i] || storeService.store.get("originItemSize");
          }
          storeService.setStore({ realSize });
          break;
        }
      }
    }
  };
};
var trimmedPlugin = (storeService) => {
  let trimmingObject = null;
  let trimmedPreviousSizes = null;
  return {
    set(key, val) {
      switch (key) {
        case "sizes": {
          if (trimmingObject && trimmingObject === val) {
            trimmingObject = null;
            return;
          }
          trimmedPreviousSizes = null;
          break;
        }
        case "trimmed": {
          const trim = val;
          if (!trimmedPreviousSizes) {
            trimmedPreviousSizes = storeService.store.get("sizes");
          }
          trimmingObject = removeMultipleAndShift(trimmedPreviousSizes, trim || {});
          storeService.setSizes(trimmingObject);
          break;
        }
      }
    }
  };
};
function removeMultipleAndShift(items, toRemove) {
  const newItems = {};
  const sortedIndexes = Object.keys(items || {}).map(Number).sort((a, b) => a - b);
  const lastIndex = sortedIndexes[sortedIndexes.length - 1];
  let shift = 0;
  for (let i = 0; i <= lastIndex; i++) {
    if (toRemove[i] !== void 0) {
      shift++;
      if (items[i] !== void 0) {
        continue;
      }
    }
    if (items[i] !== void 0) {
      newItems[i - shift] = items[i];
    }
  }
  return newItems;
}
function initialBase() {
  return {
    indexes: [],
    count: 0,
    // hidden items
    trimmed: null,
    // virtual item index to size
    sizes: {},
    // order in indexes[] to coordinate
    positionIndexToItem: {},
    // initial element to coordinate ^
    indexToItem: {},
    positionIndexes: []
  };
}
function initialState() {
  return Object.assign(Object.assign({}, initialBase()), {
    // size which all items can take
    realSize: 0,
    // initial item size if it wasn't changed
    originItemSize: 0
  });
}
var DimensionStore = class {
  constructor(type) {
    this.type = type;
    this.store = createStore(initialState());
    this.store.use(trimmedPlugin({
      store: this.store,
      setSizes: this.setDimensionSize.bind(this)
    }));
    this.store.use(recalculateRealSizePlugin({
      store: this.store,
      setStore: this.setStore.bind(this)
    }));
  }
  getCurrentState() {
    const state = initialState();
    const keys = Object.keys(state);
    return reduce(keys, (r, k) => {
      const data = this.store.get(k);
      r[k] = data;
      return r;
    }, state);
  }
  dispose() {
    setStore(this.store, initialState());
  }
  setStore(data) {
    setStore(this.store, data);
  }
  drop() {
    setStore(this.store, initialBase());
  }
  /**
   * Set custom dimension sizes and overwrite old
   * Generates new indexes based on sizes
   * @param sizes - sizes to set
   */
  setDimensionSize(sizes = {}) {
    const dimensionData = calculateDimensionData(this.store.get("originItemSize"), sizes);
    setStore(this.store, Object.assign(Object.assign({}, dimensionData), { sizes }));
  }
  updateSizesPositionByIndexes(newItemsOrder, prevItemsOrder = []) {
    const customSizes = Object.assign({}, this.store.get("sizes"));
    if (!Object.keys(customSizes).length) {
      return;
    }
    const originalIndices = {};
    prevItemsOrder.forEach((physIndex, virtIndex) => {
      if (!originalIndices[physIndex]) {
        originalIndices[physIndex] = [];
      }
      originalIndices[physIndex].push(virtIndex);
    });
    const newSizes = {};
    newItemsOrder.forEach((physIndex, virtIndex) => {
      const indices = originalIndices[physIndex];
      if (indices && indices.length > 0) {
        const originalIndex = indices.shift();
        if (originalIndex !== void 0 && originalIndex !== virtIndex && customSizes[originalIndex]) {
          newSizes[virtIndex] = customSizes[originalIndex];
          delete customSizes[originalIndex];
        }
      }
    });
    if (Object.keys(newSizes).length) {
      this.setDimensionSize(Object.assign(Object.assign({}, customSizes), newSizes));
    }
  }
};
function defaultState() {
  return {
    range: null,
    tempRange: null,
    tempRangeType: null,
    focus: null,
    edit: null,
    lastCell: null,
    nextFocus: null
  };
}
var SelectionStore = class {
  constructor() {
    this.unsubscribe = [];
    this.store = createStore(defaultState());
    this.store.on("set", (key, newVal) => {
      if (key === "tempRange" && !newVal) {
        this.store.set("tempRangeType", null);
      }
    });
  }
  onChange(propName, cb) {
    this.unsubscribe.push(this.store.onChange(propName, cb));
  }
  clearFocus() {
    setStore(this.store, { focus: null, range: null, edit: null, tempRange: null });
  }
  setFocus(focus, end) {
    if (!end) {
      setStore(this.store, { focus });
    } else {
      setStore(this.store, {
        focus,
        range: getRange(focus, end),
        edit: null,
        tempRange: null
      });
    }
  }
  setNextFocus(focus) {
    setStore(this.store, { nextFocus: focus });
  }
  setTempArea(range) {
    setStore(this.store, { tempRange: range === null || range === void 0 ? void 0 : range.area, tempRangeType: range === null || range === void 0 ? void 0 : range.type, edit: null });
  }
  clearTemp() {
    setStore(this.store, { tempRange: null });
  }
  /** Can be applied from selection change or from simple keyboard change clicks */
  setRangeArea(range) {
    setStore(this.store, { range, edit: null, tempRange: null });
  }
  setRange(start, end) {
    const range = getRange(start, end);
    this.setRangeArea(range);
  }
  setLastCell(lastCell) {
    setStore(this.store, { lastCell });
  }
  setEdit(val) {
    const focus = this.store.get("focus");
    if (focus && typeof val === "string") {
      setStore(this.store, {
        edit: { x: focus.x, y: focus.y, val }
      });
      return;
    }
    setStore(this.store, { edit: null });
  }
  dispose() {
    this.unsubscribe.forEach((f) => f());
    this.store.dispose();
  }
};
var BasePlugin = class {
  constructor(revogrid, providers) {
    this.revogrid = revogrid;
    this.providers = providers;
    this.h = h;
    this.subscriptions = {};
  }
  /**
   *
   * @param eventName - event name to subscribe to in revo-grid component (e.g. 'beforeheaderclick')
   * @param callback - callback function for event
   */
  addEventListener(eventName, callback) {
    this.revogrid.addEventListener(eventName, callback);
    this.subscriptions[eventName] = callback;
  }
  /**
   * Subscribe to property change in revo-grid component
   * You can return false in callback to prevent default value set
   *
   * @param prop - property name
   * @param callback - callback function
   * @param immediate - trigger callback immediately with current value
   */
  watch(prop, callback, { immediate } = { immediate: false }) {
    const nativeValueDesc = Object.getOwnPropertyDescriptor(this.revogrid, prop) || Object.getOwnPropertyDescriptor(this.revogrid.constructor.prototype, prop);
    Object.defineProperty(this.revogrid, prop, {
      set(val) {
        var _a;
        const keepDefault = callback(val);
        if (keepDefault === false) {
          return;
        }
        return (_a = nativeValueDesc === null || nativeValueDesc === void 0 ? void 0 : nativeValueDesc.set) === null || _a === void 0 ? void 0 : _a.call(this, val);
      },
      get() {
        var _a;
        return (_a = nativeValueDesc === null || nativeValueDesc === void 0 ? void 0 : nativeValueDesc.get) === null || _a === void 0 ? void 0 : _a.call(this);
      }
    });
    if (immediate) {
      callback(nativeValueDesc === null || nativeValueDesc === void 0 ? void 0 : nativeValueDesc.value);
    }
  }
  /**
   * Remove event listener
   * @param eventName
   */
  removeEventListener(eventName) {
    this.revogrid.removeEventListener(eventName, this.subscriptions[eventName]);
    delete this.subscriptions[eventName];
  }
  /**
   * Emit event from revo-grid component
   * Event can be cancelled by calling event.preventDefault() in callback
   */
  emit(eventName, detail) {
    const event = new CustomEvent(eventName, { detail, cancelable: true });
    this.revogrid.dispatchEvent(event);
    return event;
  }
  /**
   * Clear all subscriptions
   */
  clearSubscriptions() {
    for (let type in this.subscriptions) {
      this.removeEventListener(type);
    }
  }
  /**
   * Destroy plugin and clear all subscriptions
   */
  destroy() {
    this.clearSubscriptions();
  }
};
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
function castFunction(value) {
  return typeof value == "function" ? value : identity;
}
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}
var LETTER_BLOCK_SIZE = 7;
var AutoSizeColumnPlugin = class extends BasePlugin {
  constructor(revogrid, providers, config) {
    super(revogrid, providers);
    this.providers = providers;
    this.config = config;
    this.autoSizeColumns = null;
    this.dataResolve = null;
    this.dataReject = null;
    this.letterBlockSize = (config === null || config === void 0 ? void 0 : config.letterBlockSize) || LETTER_BLOCK_SIZE;
    if (config === null || config === void 0 ? void 0 : config.preciseSize) {
      this.precsizeCalculationArea = this.initiatePresizeElement();
      revogrid.appendChild(this.precsizeCalculationArea);
    }
    const aftersourceset = ({ detail: { source } }) => {
      this.setSource(source);
    };
    const beforecolumnsset = ({ detail: { columns } }) => {
      this.columnSet(columns);
    };
    this.addEventListener("beforecolumnsset", beforecolumnsset);
    switch (config === null || config === void 0 ? void 0 : config.mode) {
      case "autoSizeOnTextOverlap":
        this.addEventListener("aftersourceset", aftersourceset);
        this.addEventListener("afteredit", ({ detail }) => {
          this.afteredit(detail);
        });
        break;
      case "autoSizeAll":
        this.addEventListener("aftersourceset", aftersourceset);
        this.addEventListener("afteredit", ({ detail }) => {
          this.afterEditAll(detail);
        });
        break;
      default:
        this.addEventListener("headerdblclick", ({ detail }) => {
          const type = getColumnType(detail.column);
          const size2 = this.getColumnSize(detail.index, type);
          if (size2) {
            this.providers.dimension.setCustomSizes(type, {
              [detail.index]: size2
            }, true);
          }
        });
        break;
    }
  }
  async setSource(source) {
    let autoSize = this.autoSizeColumns;
    if (this.dataReject) {
      this.dataReject();
      this.clearPromise();
    }
    if (!autoSize) {
      const request = new Promise((resolve, reject) => {
        this.dataResolve = resolve;
        this.dataReject = reject;
      });
      try {
        autoSize = await request;
      } catch (e) {
        return;
      }
    }
    forEach(autoSize, (_v, type) => {
      const sizes = {};
      forEach(autoSize[type], (rgCol) => {
        rgCol.size = sizes[rgCol.index] = source.reduce((prev, rgRow) => Math.max(prev, this.getLength(rgRow[rgCol.prop])), this.getLength(rgCol.name || ""));
      });
      this.providers.dimension.setCustomSizes(type, sizes, true);
    });
  }
  getLength(len) {
    var _a;
    const padding = 15;
    if (!len) {
      return 0;
    }
    try {
      const str = len.toString();
      if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.preciseSize) {
        this.precsizeCalculationArea.innerText = str;
        return this.precsizeCalculationArea.scrollWidth + padding * 2;
      }
      return str.length * this.letterBlockSize + padding * 2;
    } catch (e) {
      return 0;
    }
  }
  afteredit(e) {
    let data;
    if (this.isRangeEdit(e)) {
      data = e.data;
    } else {
      data = { 0: { [e.prop]: e.val } };
    }
    forEach(this.autoSizeColumns, (columns, type) => {
      const sizes = {};
      forEach(columns, (rgCol) => {
        var _a;
        const size2 = reduce(data, (prev, rgRow) => {
          if (typeof rgRow[rgCol.prop] === "undefined") {
            return prev;
          }
          return Math.max(prev || 0, this.getLength(rgRow[rgCol.prop]));
        }, void 0);
        if (size2 && ((_a = rgCol.size) !== null && _a !== void 0 ? _a : 0) < size2) {
          rgCol.size = sizes[rgCol.index] = size2;
        }
      });
      this.providers.dimension.setCustomSizes(type, sizes, true);
    });
  }
  afterEditAll(e) {
    const props = {};
    if (this.isRangeEdit(e)) {
      forEach(e.data, (r) => forEach(r, (_v, p) => props[p] = true));
    } else {
      props[e.prop] = true;
    }
    forEach(this.autoSizeColumns, (columns, type) => {
      const sizes = {};
      forEach(columns, (rgCol) => {
        if (props[rgCol.prop]) {
          const size2 = this.getColumnSize(rgCol.index, type);
          if (size2) {
            sizes[rgCol.index] = size2;
          }
        }
      });
      this.providers.dimension.setCustomSizes(type, sizes, true);
    });
  }
  getColumnSize(index, type) {
    var _a, _b;
    const rgCol = (_b = (_a = this.autoSizeColumns) === null || _a === void 0 ? void 0 : _a[type]) === null || _b === void 0 ? void 0 : _b[index];
    if (!rgCol) {
      return 0;
    }
    return reduce(this.providers.data.stores, (r, s) => {
      const perStore = reduce(s.store.get("items"), (prev, _row, i) => {
        const item = getSourceItem(s.store, i);
        return Math.max(prev || 0, this.getLength(item === null || item === void 0 ? void 0 : item[rgCol.prop]));
      }, 0);
      return Math.max(r, perStore);
    }, rgCol.size || 0);
  }
  columnSet(columns) {
    var _a;
    for (let t of columnTypes) {
      const type = t;
      const cols = columns[type];
      for (let i in cols) {
        if (cols[i].autoSize || ((_a = this.config) === null || _a === void 0 ? void 0 : _a.allColumns)) {
          if (!this.autoSizeColumns) {
            this.autoSizeColumns = {};
          }
          if (!this.autoSizeColumns[type]) {
            this.autoSizeColumns[type] = {};
          }
          this.autoSizeColumns[type][i] = Object.assign(Object.assign({}, cols[i]), { index: parseInt(i, 10) });
        }
      }
    }
    if (this.dataResolve) {
      this.dataResolve(this.autoSizeColumns || {});
      this.clearPromise();
    }
  }
  clearPromise() {
    this.dataResolve = null;
    this.dataReject = null;
  }
  isRangeEdit(e) {
    return !!e.data;
  }
  initiatePresizeElement() {
    var _a;
    const styleForFontTest = {
      position: "absolute",
      fontSize: "14px",
      height: "0",
      width: "0",
      whiteSpace: "nowrap",
      top: "0",
      overflowX: "scroll",
      display: "block"
    };
    const el = document.createElement("div");
    for (let s in styleForFontTest) {
      el.style[s] = (_a = styleForFontTest[s]) !== null && _a !== void 0 ? _a : "";
    }
    el.classList.add("revo-test-container");
    return el;
  }
  destroy() {
    var _a;
    super.destroy();
    (_a = this.precsizeCalculationArea) === null || _a === void 0 ? void 0 : _a.remove();
  }
};
var StretchColumn = class extends BasePlugin {
  constructor(revogrid, providers) {
    super(revogrid, providers);
    this.providers = providers;
    this.stretchedColumn = null;
    this.scrollSize = getScrollbarSize(document);
    const beforecolumnapplied = ({ detail: { columns } }) => this.applyStretch(columns);
    this.addEventListener("beforecolumnapplied", beforecolumnapplied);
  }
  setScroll({ type, hasScroll }) {
    var _a;
    if (type === "rgRow" && this.stretchedColumn && ((_a = this.stretchedColumn) === null || _a === void 0 ? void 0 : _a.initialSize) === this.stretchedColumn.size) {
      if (hasScroll) {
        this.stretchedColumn.size -= this.scrollSize;
        this.apply();
        this.dropChanges();
      }
    }
  }
  activateChanges() {
    const setScroll = ({ detail }) => this.setScroll(detail);
    this.addEventListener("scrollchange", setScroll);
  }
  dropChanges() {
    this.stretchedColumn = null;
    this.removeEventListener("scrollchange");
  }
  apply() {
    if (!this.stretchedColumn) {
      return;
    }
    const type = "rgCol";
    const sizes = this.providers.dimension.stores[type].store.get("sizes");
    this.providers.dimension.setCustomSizes(type, Object.assign(Object.assign({}, sizes), { [this.stretchedColumn.index]: this.stretchedColumn.size }), true);
  }
  /**
   * Apply stretch changes
   */
  applyStretch(columns) {
    this.dropChanges();
    let sizeDifference = this.revogrid.clientWidth - 1;
    forEach(columns, (_, type) => {
      const realSize = this.providers.dimension.stores[type].store.get("realSize");
      sizeDifference -= realSize;
    });
    if (this.revogrid.rowHeaders) {
      const itemsLength = this.providers.data.stores.rgRow.store.get("source").length;
      const header = this.revogrid.rowHeaders;
      const rowHeaderSize = calculateRowHeaderSize(itemsLength, typeof header === "object" ? header : void 0);
      if (rowHeaderSize) {
        sizeDifference -= rowHeaderSize;
      }
    }
    if (sizeDifference > 0) {
      const index = columns.rgCol.length - 1;
      const last = columns.rgCol[index];
      const colSize = (last === null || last === void 0 ? void 0 : last.size) || this.revogrid.colSize || 0;
      const size2 = sizeDifference + colSize - 1;
      if (last && !last.autoSize && colSize < size2) {
        this.stretchedColumn = {
          initialSize: size2,
          index,
          size: size2
        };
        this.apply();
        this.activateChanges();
      }
    }
  }
};
function isStretchPlugin(plugin) {
  return !!plugin.applyStretch;
}
function baseClamp(number, lower, upper) {
  if (number === number) {
    {
      number = number <= upper ? number : upper;
    }
    {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var MAX_ARRAY_LENGTH = 4294967295;
function toLength(value) {
  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
}
function baseFill(array, value, start, end) {
  var length = array.length;
  start = toInteger(start);
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end === void 0 || end > length ? length : toInteger(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}
function fill(array, value, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  return baseFill(array, value, start, end);
}
var INITIAL = {
  mime: "text/csv",
  fileKind: "csv",
  // BOM signature
  bom: true,
  columnDelimiter: ",",
  rowDelimiter: "\r\n",
  encoding: ""
};
var CARRIAGE_RETURN = String.fromCharCode(13);
var LINE_FEED = String.fromCharCode(10);
var DOUBLE_QT = String.fromCharCode(34);
var NO_BREAK_SPACE = String.fromCharCode(65279);
var escapeRegex = new RegExp('"', "g");
var ExportCsv = class {
  constructor(options = {}) {
    this.options = Object.assign(Object.assign({}, INITIAL), options);
  }
  doExport({ data, headers, props }) {
    let result = this.options.bom ? NO_BREAK_SPACE : "";
    if ((headers === null || headers === void 0 ? void 0 : headers.length) > 0) {
      headers.forEach((header) => {
        if (!header.length) {
          return;
        }
        result += this.prepareHeader(header, this.options.columnDelimiter);
        result += this.options.rowDelimiter;
      });
    }
    data.forEach((rgRow, index) => {
      if (index > 0) {
        result += this.options.rowDelimiter;
      }
      if (isGrouping(rgRow)) {
        result += this.parseCell(getGroupingName(rgRow), this.options.columnDelimiter);
        return;
      }
      result += props.map((p) => this.parseCell(rgRow[p], this.options.columnDelimiter)).join(this.options.columnDelimiter);
    });
    return result;
  }
  prepareHeader(columnHeaders, columnDelimiter) {
    let result = "";
    const newColumnHeaders = columnHeaders.map((v) => this.parseCell(v, columnDelimiter, true));
    result += newColumnHeaders.join(columnDelimiter);
    return result;
  }
  parseCell(value, columnDelimiter, force = false) {
    let escape = value;
    if (typeof value !== "string") {
      escape = JSON.stringify(value);
    }
    const toEscape = [CARRIAGE_RETURN, DOUBLE_QT, LINE_FEED, columnDelimiter];
    if (typeof escape === "undefined") {
      return "";
    }
    if (escape !== "" && (force || toEscape.some((i) => escape.indexOf(i) >= 0))) {
      return `"${escape.replace(escapeRegex, '""')}"`;
    }
    return escape;
  }
};
var ExportTypes;
(function(ExportTypes2) {
  ExportTypes2["csv"] = "csv";
})(ExportTypes || (ExportTypes = {}));
var ExportFilePlugin = class extends BasePlugin {
  /** Exports string */
  async exportString(options = {}, t = ExportTypes.csv) {
    const data = await this.beforeexport();
    if (!data) {
      return null;
    }
    return this.formatter(t, options).doExport(data);
  }
  /** Exports Blob */
  async exportBlob(options = {}, t = ExportTypes.csv) {
    return await this.getBlob(this.formatter(t, options));
  }
  /** Export file */
  async exportFile(options = {}, t = ExportTypes.csv) {
    const formatter = this.formatter(t, options);
    const URL = window.URL || window.webkitURL;
    const a = document.createElement("a");
    const { filename, fileKind } = formatter.options;
    const name = `${filename}.${fileKind}`;
    const blob = await this.getBlob(formatter);
    const url = blob ? URL.createObjectURL(blob) : "";
    a.style.display = "none";
    a.setAttribute("href", url);
    a.setAttribute("download", name);
    this.revogrid.appendChild(a);
    a.dispatchEvent(new MouseEvent("click"));
    this.revogrid.removeChild(a);
    await timeout(120);
    URL.revokeObjectURL(url);
  }
  /** Blob object */
  async getBlob(formatter) {
    const type = `${formatter.options.mime};charset=${formatter.options.encoding}`;
    if (typeof Blob !== "undefined") {
      const data = await this.beforeexport();
      if (!data) {
        return null;
      }
      return new Blob([formatter.doExport(data)], { type });
    }
    return null;
  }
  // before event
  async beforeexport() {
    let data = await this.getData();
    const event = this.emit("beforeexport", { data });
    if (event.defaultPrevented) {
      return null;
    }
    return event.detail.data;
  }
  async getData() {
    const data = await this.getSource();
    const colSource = [];
    const colPromises = [];
    columnTypes.forEach((t, i) => {
      colPromises.push(this.getColPerSource(t).then((s) => colSource[i] = s));
    });
    await Promise.all(colPromises);
    const columns = {
      headers: [],
      props: []
    };
    for (let source of colSource) {
      source.headers.forEach((h2, i) => {
        if (!columns.headers[i]) {
          columns.headers[i] = [];
        }
        columns.headers[i].push(...h2);
      });
      columns.props.push(...source.props);
    }
    return Object.assign({ data }, columns);
  }
  async getColPerSource(t) {
    const store = await this.revogrid.getColumnStore(t);
    const source = store.get("source");
    const virtualIndexes = store.get("items");
    const depth = store.get("groupingDepth");
    const groups = store.get("groups");
    const colNames = [];
    const colProps = [];
    virtualIndexes.forEach((v) => {
      const prop = source[v].prop;
      colNames.push(source[v].name || "");
      colProps.push(prop);
    });
    const rows = this.getGroupHeaders(depth, groups, virtualIndexes);
    rows.push(colNames);
    return {
      headers: rows,
      props: colProps
    };
  }
  getGroupHeaders(depth, groups, items) {
    const rows = [];
    const template = fill(new Array(items.length), "");
    for (let d = 0; d < depth; d++) {
      const rgRow = [...template];
      rows.push(rgRow);
      if (!groups[d]) {
        continue;
      }
      const levelGroups = groups[d];
      levelGroups.forEach((group) => {
        const minIndex = group.indexes[0];
        if (typeof minIndex === "number") {
          rgRow[minIndex] = group.name;
        }
      });
    }
    return rows;
  }
  async getSource() {
    const data = [];
    const promisesData = [];
    rowTypes.forEach((t) => {
      const dataPart = [];
      data.push(dataPart);
      const promise = this.revogrid.getVisibleSource(t).then((d) => dataPart.push(...d));
      promisesData.push(promise);
    });
    await Promise.all(promisesData);
    return data.reduce((r, v) => {
      r.push(...v);
      return r;
    }, []);
  }
  // get correct class for future multiple types support
  formatter(type, options = {}) {
    switch (type) {
      case ExportTypes.csv:
        return new ExportCsv(options);
      default:
        throw new Error("Unknown format");
    }
  }
};
var eq = (value, extra) => {
  if (typeof value === "undefined" || value === null && !extra) {
    return true;
  }
  if (typeof value !== "string") {
    value = JSON.stringify(value);
  }
  const filterVal = extra === null || extra === void 0 ? void 0 : extra.toString().toLocaleLowerCase();
  if ((filterVal === null || filterVal === void 0 ? void 0 : filterVal.length) === 0) {
    return true;
  }
  return value.toLocaleLowerCase() === filterVal;
};
var notEq = (value, extra) => !eq(value, extra);
notEq.extra = "input";
eq.extra = "input";
var gtThan = function(value, extra) {
  let conditionValue;
  if (typeof value === "number" && typeof extra !== "undefined" && extra !== null) {
    conditionValue = parseFloat(extra === null || extra === void 0 ? void 0 : extra.toString());
    return value > conditionValue;
  }
  return false;
};
gtThan.extra = "input";
var gtThanEq = function(value, extra) {
  return eq(value, extra) || gtThan(value, extra);
};
gtThanEq.extra = "input";
var lt = function(value, extra) {
  let conditionValue;
  if (typeof value === "number" && typeof extra !== "undefined" && extra !== null) {
    conditionValue = parseFloat(extra.toString());
    return value < conditionValue;
  } else {
    return false;
  }
};
lt.extra = "input";
var lsEq = function(value, extra) {
  return eq(value, extra) || lt(value, extra);
};
lsEq.extra = "input";
var set = (value) => !(value === "" || value === null || value === void 0);
var notSet = (value) => !set(value);
var beginsWith = (value, extra) => {
  if (!value) {
    return false;
  }
  if (!extra) {
    return true;
  }
  if (typeof value !== "string") {
    value = JSON.stringify(value);
  }
  if (typeof extra !== "string") {
    extra = JSON.stringify(extra);
  }
  return value.toLocaleLowerCase().indexOf(extra.toLocaleLowerCase()) === 0;
};
beginsWith.extra = "input";
var contains = (value, extra) => {
  if (!extra) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (extra) {
    if (typeof value !== "string") {
      value = JSON.stringify(value);
    }
    return value.toLocaleLowerCase().indexOf(extra.toString().toLowerCase()) > -1;
  }
  return true;
};
var notContains = (value, extra) => {
  return !contains(value, extra);
};
notContains.extra = "input";
contains.extra = "input";
var filterCoreFunctionsIndexedByType = {
  none: () => true,
  empty: notSet,
  notEmpty: set,
  eq,
  notEq,
  begins: beginsWith,
  contains,
  notContains,
  eqN: eq,
  neqN: notEq,
  gt: gtThan,
  gte: gtThanEq,
  lt,
  lte: lsEq
};
var filterTypes = {
  string: ["notEmpty", "empty", "eq", "notEq", "begins", "contains", "notContains"],
  number: ["notEmpty", "empty", "eqN", "neqN", "gt", "gte", "lt", "lte"]
};
var filterNames = {
  none: "None",
  empty: "Not set",
  notEmpty: "Set",
  eq: "Equal",
  notEq: "Not equal",
  begins: "Begins with",
  contains: "Contains",
  notContains: "Does not contain",
  eqN: "=",
  neqN: "!=",
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<="
};
var FILTER_TRIMMED_TYPE = "filter";
var FILTER_CONFIG_CHANGED_EVENT = "filterconfigchanged";
var FILTE_PANEL = "revogr-filter-panel";
var FilterPlugin = class extends BasePlugin {
  constructor(revogrid, providers, config) {
    var _a;
    super(revogrid, providers);
    this.revogrid = revogrid;
    this.config = config;
    this.filterCollection = {};
    this.multiFilterItems = {};
    this.filterByType = Object.assign({}, filterTypes);
    this.filterNameIndexByType = Object.assign({}, filterNames);
    this.filterFunctionsIndexedByType = Object.assign({}, filterCoreFunctionsIndexedByType);
    this.filterProp = FILTER_PROP;
    if (config) {
      this.initConfig(config);
    }
    const existingNodes = this.revogrid.registerVNode.filter((n) => typeof n === "object" && n.$tag$ !== FILTE_PANEL);
    this.revogrid.registerVNode = [
      ...existingNodes,
      h(
        "revogr-filter-panel",
        { filterNames: this.filterNameIndexByType, filterEntities: this.filterFunctionsIndexedByType, filterCaptions: (_a = config === null || config === void 0 ? void 0 : config.localization) === null || _a === void 0 ? void 0 : _a.captions, onFilterChange: (e) => this.onFilterChange(e.detail), onResetChange: (e) => this.onFilterReset(e.detail), disableDynamicFiltering: config === null || config === void 0 ? void 0 : config.disableDynamicFiltering, closeOnOutsideClick: config === null || config === void 0 ? void 0 : config.closeFilterPanelOnOutsideClick, ref: (e) => this.pop = e },
        " ",
        this.extraContent()
      )
    ];
    const aftersourceset = async () => {
      const filterCollectionProps = Object.keys(this.filterCollection);
      if (filterCollectionProps.length > 0) {
        filterCollectionProps.forEach((prop, index) => {
          if (!this.multiFilterItems[prop]) {
            this.multiFilterItems[prop] = [
              {
                id: index,
                type: this.filterCollection[prop].type,
                value: this.filterCollection[prop].value,
                relation: "and"
              }
            ];
          }
        });
      }
      if (Object.keys(this.multiFilterItems).length === 0) {
        return;
      }
      await this.runFiltering(this.multiFilterItems);
    };
    this.addEventListener("headerclick", (e) => this.headerclick(e));
    this.addEventListener(FILTER_CONFIG_CHANGED_EVENT, ({ detail }) => {
      if (!detail || typeof detail === "object" && (!detail.multiFilterItems || !Object.keys(detail.multiFilterItems).length)) {
        this.clearFiltering();
        return;
      }
      if (typeof detail === "object") {
        this.initConfig(detail);
      }
      aftersourceset();
    });
    this.addEventListener("aftersourceset", aftersourceset);
    this.addEventListener("filter", ({ detail }) => this.onFilterChange(detail));
  }
  beforeshow(_) {
  }
  extraContent() {
    return null;
  }
  initConfig(config) {
    if (config.multiFilterItems) {
      this.multiFilterItems = Object.assign({}, config.multiFilterItems);
    } else {
      this.multiFilterItems = {};
    }
    if (config.customFilters) {
      for (let customFilterType in config.customFilters) {
        const cFilter = config.customFilters[customFilterType];
        if (!this.filterByType[cFilter.columnFilterType]) {
          this.filterByType[cFilter.columnFilterType] = [];
        }
        this.filterByType[cFilter.columnFilterType].push(customFilterType);
        this.filterFunctionsIndexedByType[customFilterType] = cFilter.func;
        this.filterNameIndexByType[customFilterType] = cFilter.name;
      }
    }
    if (config.filterProp) {
      this.filterProp = config.filterProp;
    }
    const cfgInlcude = config.include;
    if (cfgInlcude) {
      const filters = {};
      for (let t in this.filterByType) {
        const newTypes = this.filterByType[t].filter((f) => cfgInlcude.indexOf(f) > -1);
        if (newTypes.length) {
          filters[t] = newTypes;
        }
      }
      if (Object.keys(filters).length > 0) {
        this.filterByType = filters;
      }
    }
    if (config.collection) {
      const filtersWithFilterFunctionPresent = Object.entries(config.collection).filter(([, item]) => this.filterFunctionsIndexedByType[item.type]);
      this.filterCollection = Object.fromEntries(filtersWithFilterFunctionPresent);
    } else {
      this.filterCollection = {};
    }
    if (config.localization) {
      if (config.localization.filterNames) {
        Object.entries(config.localization.filterNames).forEach(([k, v]) => {
          if (this.filterNameIndexByType[k] != void 0) {
            this.filterNameIndexByType[k] = v;
          }
        });
      }
    }
  }
  async headerclick(e) {
    var _a, _b;
    const el = (_a = e.detail.originalEvent) === null || _a === void 0 ? void 0 : _a.target;
    if (!isFilterBtn(el)) {
      return;
    }
    e.preventDefault();
    if (!this.pop) {
      return;
    }
    const gridPos = this.revogrid.getBoundingClientRect();
    const buttonPos = el.getBoundingClientRect();
    const prop = e.detail.prop;
    const data = Object.assign(Object.assign(Object.assign({}, e.detail), this.filterCollection[prop]), { x: buttonPos.x - gridPos.x, y: buttonPos.y - gridPos.y + buttonPos.height, autoCorrect: true, filterTypes: this.getColumnFilter(e.detail.filter), filterItems: this.multiFilterItems, extraContent: this.extraHyperContent });
    (_b = this.beforeshow) === null || _b === void 0 ? void 0 : _b.call(this, data);
    this.pop.show(data);
  }
  getColumnFilter(type) {
    let filterType = "string";
    if (!type) {
      return { [filterType]: this.filterByType[filterType] };
    }
    if (this.isValidType(type)) {
      filterType = type;
    } else if (typeof type === "object" && type.length) {
      return type.reduce((r, multiType) => {
        if (this.isValidType(multiType)) {
          r[multiType] = this.filterByType[multiType];
        }
        return r;
      }, {});
    }
    return { [filterType]: this.filterByType[filterType] };
  }
  isValidType(type) {
    return !!(typeof type === "string" && this.filterByType[type]);
  }
  /**
   * Called on internal component change
   */
  async onFilterChange(filterItems) {
    this.multiFilterItems = filterItems;
    this.runFiltering(this.multiFilterItems);
  }
  onFilterReset(prop) {
    delete this.multiFilterItems[prop !== null && prop !== void 0 ? prop : ""];
    this.onFilterChange(this.multiFilterItems);
  }
  /**
   * Triggers grid filtering
   */
  async doFiltering(collection, source, columns, filterItems) {
    const columnsToUpdate = [];
    const columnByProp = {};
    columns.forEach((rgCol) => {
      const column = Object.assign({}, rgCol);
      const hasFilter = filterItems[column.prop];
      columnByProp[column.prop] = column;
      if (column[this.filterProp] && !hasFilter) {
        delete column[this.filterProp];
        columnsToUpdate.push(column);
      }
      if (!column[this.filterProp] && hasFilter) {
        columnsToUpdate.push(column);
        column[this.filterProp] = true;
      }
    });
    const itemsToTrim = this.getRowFilter(source, filterItems, columnByProp);
    const { defaultPrevented, detail } = this.emit("beforefiltertrimmed", {
      collection,
      itemsToFilter: itemsToTrim,
      source,
      filterItems
    });
    if (defaultPrevented) {
      return;
    }
    this.providers.data.setTrimmed({ [FILTER_TRIMMED_TYPE]: detail.itemsToFilter });
    this.providers.column.updateColumns(columnsToUpdate);
    this.emit("afterfilterapply", {
      multiFilterItems: filterItems,
      source,
      collection
    });
  }
  async clearFiltering() {
    this.multiFilterItems = {};
    await this.runFiltering(this.multiFilterItems);
  }
  async runFiltering(multiFilterItems) {
    const collection = {};
    const filterProps = Object.keys(multiFilterItems);
    for (const prop of filterProps) {
      if (multiFilterItems[prop].length > 0) {
        const firstFilterItem = multiFilterItems[prop][0];
        collection[prop] = {
          type: firstFilterItem.type,
          value: firstFilterItem.value
        };
      }
    }
    this.filterCollection = collection;
    const columns = this.providers.column.getColumns();
    const source = this.providers.data.stores["rgRow"].store.get("source");
    const { defaultPrevented, detail } = this.emit("beforefilterapply", {
      collection: this.filterCollection,
      source,
      columns,
      filterItems: this.multiFilterItems
    });
    if (defaultPrevented) {
      return;
    }
    this.doFiltering(detail.collection, detail.source, detail.columns, detail.filterItems);
  }
  /**
   * Get trimmed rows based on filter
   */
  getRowFilter(rows, filterItems, columnByProp) {
    const propKeys = Object.keys(filterItems);
    const trimmed = {};
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      for (const prop of propKeys) {
        if (this.shouldTrimRow(filterItems[prop], prop, columnByProp[prop], rows[rowIndex])) {
          trimmed[rowIndex] = true;
        }
      }
    }
    return trimmed;
  }
  shouldTrimRow(propFilters, prop, column, model = {}) {
    let propFilterSatisfiedCount = 0;
    let lastFilterResults = [];
    for (const [filterIndex, filterData] of propFilters.entries()) {
      const filterFunc = this.filterFunctionsIndexedByType[filterData.type];
      const value = column ? getCellDataParsed(model, column) : model[prop];
      if (filterData.relation === "or") {
        lastFilterResults = [];
        if (filterFunc(value, filterData.value)) {
          continue;
        }
        propFilterSatisfiedCount++;
      } else {
        lastFilterResults.push(!filterFunc(value, filterData.value));
        if (isFinalAndFilter(filterIndex, propFilters)) {
          if (allAndConditionsSatisfied(lastFilterResults)) {
            lastFilterResults = [];
            continue;
          }
          propFilterSatisfiedCount += lastFilterResults.length;
          lastFilterResults = [];
        }
      }
    }
    return propFilterSatisfiedCount === propFilters.length;
  }
};
function isFinalAndFilter(index, filters) {
  const nextFilter = filters[index + 1];
  return !nextFilter || !!nextFilter.relation && nextFilter.relation !== "and";
}
function allAndConditionsSatisfied(pendingResults) {
  return !pendingResults.includes(true);
}
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}
var asciiSize = baseProperty("length");
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}
function stringSize(string) {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
}
var mapTag = "[object Map]";
var setTag = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }
  var tag = getTag(collection);
  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }
  return baseKeys(collection).length;
}
function sortIndexByItems(indexes, source, sortingFunc = {}) {
  if (Object.entries(sortingFunc).length === 0) {
    return [...Array(indexes.length).keys()];
  }
  return indexes.sort((a, b) => {
    const itemA = source[a];
    const itemB = source[b];
    for (const [prop, cmp] of Object.entries(sortingFunc)) {
      if (isGrouping(itemA)) {
        if (itemA["__rvgr-prop"] !== prop) {
          return 0;
        }
      }
      if (isGrouping(itemB)) {
        if (itemB["__rvgr-prop"] !== prop) {
          return 0;
        }
      }
      const sorted = cmp === null || cmp === void 0 ? void 0 : cmp(prop, itemA, itemB);
      if (sorted) {
        return sorted;
      }
    }
    return 0;
  });
}
function defaultCellCompare(prop, a, b) {
  const aRaw = this.column ? getCellRaw(a, this.column) : a === null || a === void 0 ? void 0 : a[prop];
  const bRaw = this.column ? getCellRaw(b, this.column) : b === null || b === void 0 ? void 0 : b[prop];
  const av = typeof aRaw === "number" ? aRaw : aRaw === null || aRaw === void 0 ? void 0 : aRaw.toString().toLowerCase();
  const bv = typeof bRaw === "number" ? bRaw : bRaw === null || bRaw === void 0 ? void 0 : bRaw.toString().toLowerCase();
  if (av === bv) {
    return 0;
  }
  if (av > bv) {
    return 1;
  }
  return -1;
}
function descCellCompare(cmp) {
  return (prop, a, b) => {
    return -1 * cmp(prop, a, b);
  };
}
function getNextOrder(currentOrder) {
  switch (currentOrder) {
    case void 0:
      return "asc";
    case "asc":
      return "desc";
    case "desc":
      return void 0;
  }
}
function getComparer(column, order) {
  var _a;
  const cellCmp = ((_a = column === null || column === void 0 ? void 0 : column.cellCompare) === null || _a === void 0 ? void 0 : _a.bind({ order })) || (defaultCellCompare === null || defaultCellCompare === void 0 ? void 0 : defaultCellCompare.bind({ column, order }));
  if (order == "asc") {
    return cellCmp;
  }
  if (order == "desc") {
    return descCellCompare(cellCmp);
  }
  return void 0;
}
var SortingPlugin = class extends BasePlugin {
  constructor(revogrid, providers, config) {
    super(revogrid, providers);
    this.revogrid = revogrid;
    this.sortingPromise = null;
    this.postponeSort = debounce((order, comparison, ignoreViewportUpdate) => this.runSorting(order, comparison, ignoreViewportUpdate), 50);
    const setConfig = (cfg) => {
      var _a;
      if (cfg) {
        const sortingFunc = {};
        const order = {};
        (_a = cfg.columns) === null || _a === void 0 ? void 0 : _a.forEach((col) => {
          sortingFunc[col.prop] = getComparer(col, col.order);
          order[col.prop] = col.order;
        });
        if (cfg.additive) {
          this.sorting = Object.assign(Object.assign({}, this.sorting), order);
          this.sortingFunc = Object.assign(Object.assign({}, this.sortingFunc), sortingFunc);
        } else {
          this.sorting = order;
          this.sortingFunc = sortingFunc;
        }
      }
    };
    setConfig(config);
    this.addEventListener("sortingconfigchanged", ({ detail }) => {
      config = detail;
      setConfig(detail);
      this.startSorting(this.sorting, this.sortingFunc);
    });
    this.addEventListener("beforeheaderrender", ({ detail }) => {
      var _a;
      const { data: column } = detail;
      if (column.sortable) {
        detail.data = Object.assign(Object.assign({}, column), { order: (_a = this.sorting) === null || _a === void 0 ? void 0 : _a[column.prop] });
      }
    });
    this.addEventListener("beforeanysource", ({ detail: { type } }) => {
      if (!!this.sorting && this.sortingFunc) {
        const event = this.emit("beforesourcesortingapply", { type, sorting: this.sorting });
        if (event.defaultPrevented) {
          return;
        }
        this.startSorting(this.sorting, this.sortingFunc);
      }
    });
    this.addEventListener("aftercolumnsset", ({ detail: { order } }) => {
      if (config) {
        return;
      }
      const columns = this.providers.column.getColumns();
      const sortingFunc = {};
      for (let prop in order) {
        const cmp = getComparer(getColumnByProp(columns, prop), order[prop]);
        sortingFunc[prop] = cmp;
      }
      this.sorting = order;
      this.sortingFunc = order && sortingFunc;
    });
    this.addEventListener("beforeheaderclick", (e) => {
      var _a, _b, _c, _d;
      if (e.defaultPrevented) {
        return;
      }
      if (!((_b = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.column) === null || _b === void 0 ? void 0 : _b.sortable)) {
        return;
      }
      this.headerclick(e.detail.column, (_d = (_c = e.detail) === null || _c === void 0 ? void 0 : _c.originalEvent) === null || _d === void 0 ? void 0 : _d.shiftKey);
    });
  }
  /**
   * Entry point for sorting, waits for all delayes, registers jobs
   */
  startSorting(order, sortingFunc, ignoreViewportUpdate) {
    if (!this.sortingPromise) {
      this.revogrid.jobsBeforeRender.push(new Promise((resolve) => {
        this.sortingPromise = resolve;
      }));
    }
    this.postponeSort(order, sortingFunc, ignoreViewportUpdate);
  }
  /**
   * Apply sorting to data on header click
   * If additive - add to existing sorting, multiple columns can be sorted
   */
  headerclick(column, additive) {
    var _a, _b, _c;
    const columnProp = column.prop;
    let order = getNextOrder((_a = this.sorting) === null || _a === void 0 ? void 0 : _a[columnProp]);
    const beforeEvent = this.emit("beforesorting", { column, order, additive });
    if (beforeEvent.defaultPrevented) {
      return;
    }
    order = beforeEvent.detail.order;
    const beforeApplyEvent = this.emit("beforesortingapply", {
      column: beforeEvent.detail.column,
      order,
      additive
    });
    if (beforeApplyEvent.defaultPrevented) {
      return;
    }
    const cmp = getComparer(beforeApplyEvent.detail.column, beforeApplyEvent.detail.order);
    if (beforeApplyEvent.detail.additive && this.sorting) {
      const sorting = {};
      const sortingFunc = {};
      if (columnProp in sorting && size(sorting) > 1 && order === void 0) {
        delete sorting[columnProp];
        delete sortingFunc[columnProp];
      } else {
        sorting[columnProp] = order;
        sortingFunc[columnProp] = cmp;
      }
      this.sorting = Object.assign(Object.assign({}, this.sorting), sorting);
      this.sortingFunc = Object.assign(Object.assign({}, this.sortingFunc), sortingFunc);
    } else {
      if (order) {
        this.sorting = { [columnProp]: order };
        this.sortingFunc = { [columnProp]: cmp };
      } else {
        (_b = this.sorting) === null || _b === void 0 ? true : delete _b[columnProp];
        (_c = this.sortingFunc) === null || _c === void 0 ? true : delete _c[columnProp];
      }
    }
    this.startSorting(this.sorting, this.sortingFunc);
  }
  runSorting(order, comparison, ignoreViewportUpdate) {
    var _a;
    this.sort(order, comparison, void 0, ignoreViewportUpdate);
    (_a = this.sortingPromise) === null || _a === void 0 ? void 0 : _a.call(this);
    this.sortingPromise = null;
  }
  /**
   * Sort items by sorting function
   * @requires proxyItems applied to row store
   * @requires source applied to row store
   *
   * @param sorting - per column sorting
   * @param data - this.stores['rgRow'].store.get('source')
   */
  sort(sorting, sortingFunc, types = rowTypes, ignoreViewportUpdate = false) {
    if (!Object.keys(sorting || {}).length) {
      for (let type of types) {
        const storeService = this.providers.data.stores[type];
        const source = storeService.store.get("source");
        const proxyItems = storeService.store.get("proxyItems");
        const newItemsOrder = Array.from({ length: source.length }, (_, i) => i);
        this.providers.dimension.updateSizesPositionByNewDataIndexes(type, newItemsOrder, proxyItems);
        storeService.setData({ proxyItems: newItemsOrder, source: [...source] });
      }
    } else {
      for (let type of types) {
        const storeService = this.providers.data.stores[type];
        const source = storeService.store.get("source");
        const proxyItems = storeService.store.get("proxyItems");
        const newItemsOrder = sortIndexByItems([...proxyItems], source, sortingFunc);
        const prevItems = storeService.store.get("items");
        storeService.setData({
          proxyItems: newItemsOrder,
          source: [...source]
        });
        const newItems = storeService.store.get("items");
        if (!ignoreViewportUpdate) {
          this.providers.dimension.updateSizesPositionByNewDataIndexes(type, newItems, prevItems);
        }
      }
    }
    columnTypes.forEach((type) => {
      this.providers.column.dataSources[type].refresh();
    });
    this.emit("aftersortingapply");
  }
};
function doCollapse(pIndex, source) {
  const model = source[pIndex];
  const collapseValue = model[PSEUDO_GROUP_ITEM_VALUE];
  const trimmed = {};
  let i = pIndex + 1;
  const total = source.length;
  while (i < total) {
    const currentModel = source[i];
    if (isGrouping(currentModel)) {
      const currentValue = currentModel[PSEUDO_GROUP_ITEM_VALUE];
      if (!currentValue.length || !currentValue.startsWith(collapseValue + ",")) {
        break;
      }
      currentModel[GROUP_EXPANDED] = false;
    }
    trimmed[i++] = true;
  }
  model[GROUP_EXPANDED] = false;
  return { trimmed };
}
function doExpand(vIndex, source, rowItemsIndexes) {
  const physicalIndex = rowItemsIndexes[vIndex];
  const model = source[physicalIndex];
  const currentGroup = getParsedGroup(model[PSEUDO_GROUP_ITEM_ID]);
  const trimmed = {};
  if (!currentGroup) {
    return { trimmed };
  }
  const groupItems = [];
  model[GROUP_EXPANDED] = true;
  let i = physicalIndex + 1;
  const total = source.length;
  let groupLevelOnly = 0;
  while (i < total) {
    const currentModel = source[i];
    const isGroup = isGrouping(currentModel);
    if (isGroup) {
      if (!isSameGroup(currentGroup, model, currentModel)) {
        break;
      } else if (!groupLevelOnly) {
        groupLevelOnly = currentModel[GROUP_DEPTH];
      }
    }
    if (!groupLevelOnly || isGroup && groupLevelOnly === currentModel[GROUP_DEPTH]) {
      trimmed[i] = false;
      groupItems.push(i);
    }
    i++;
  }
  const result = {
    trimmed
  };
  if (groupItems.length) {
    const items = [...rowItemsIndexes];
    items.splice(vIndex + 1, 0, ...groupItems);
    result.items = items;
  }
  return result;
}
var TRIMMED_GROUPING = "grouping";
function processDoubleConversionTrimmed(initiallyTrimed, firstLevelMap, secondLevelMap) {
  const trimemedOptionsToUpgrade = {};
  for (let type in initiallyTrimed) {
    if (type === TRIMMED_GROUPING) {
      continue;
    }
    const items = initiallyTrimed[type];
    const newItems = {};
    for (let initialIndex in items) {
      let newConversionIndex = firstLevelMap[initialIndex];
      if (secondLevelMap) {
        newConversionIndex = secondLevelMap[newConversionIndex];
      }
      if (items[initialIndex]) {
        newItems[newConversionIndex] = true;
        if (newConversionIndex !== parseInt(initialIndex, 10)) {
          trimemedOptionsToUpgrade[type] = newItems;
        }
      }
    }
  }
  return trimemedOptionsToUpgrade;
}
var GroupingRowPlugin = class extends BasePlugin {
  getStore(type = GROUPING_ROW_TYPE) {
    return this.providers.data.stores[type].store;
  }
  constructor(revogrid, providers) {
    super(revogrid, providers);
  }
  // befoce cell focus
  onFocus(e) {
    if (isGrouping(e.detail.model)) {
      e.preventDefault();
    }
  }
  // expand event triggered
  onExpand({ virtualIndex }) {
    const { source } = getSource(this.getStore().get("source"), this.getStore().get("proxyItems"));
    let newTrimmed = this.getStore().get("trimmed")[TRIMMED_GROUPING];
    let i = getPhysical(this.getStore(), virtualIndex);
    const isExpanded = getExpanded(source[i]);
    if (!isExpanded) {
      const { trimmed, items } = doExpand(virtualIndex, source, this.getStore().get("items"));
      newTrimmed = Object.assign(Object.assign({}, newTrimmed), trimmed);
      if (items) {
        setItems(this.getStore(), items);
      }
    } else {
      const { trimmed } = doCollapse(i, source);
      newTrimmed = Object.assign(Object.assign({}, newTrimmed), trimmed);
      this.revogrid.clearFocus();
    }
    this.getStore().set("source", source);
    this.revogrid.addTrimmed(newTrimmed, TRIMMED_GROUPING);
  }
  setColumnGrouping(cols) {
    if (cols === null || cols === void 0 ? void 0 : cols.length) {
      cols[0][PSEUDO_GROUP_COLUMN] = true;
      return true;
    }
    return false;
  }
  setColumns({ columns }) {
    for (let type of columnTypes) {
      if (this.setColumnGrouping(columns[type])) {
        break;
      }
    }
  }
  // evaluate drag between groups
  onDrag(e) {
    const { from, to } = e.detail;
    const isDown = to - from >= 0;
    const { source } = getSource(this.getStore().get("source"), this.getStore().get("proxyItems"));
    const items = this.getStore().get("items");
    let i = isDown ? from : to;
    const end = isDown ? to : from;
    for (; i < end; i++) {
      const model = source[items[i]];
      const isGroup = isGrouping(model);
      if (isGroup) {
        e.preventDefault();
        return;
      }
    }
  }
  beforeTrimmedApply(trimmed, type) {
    if (type === FILTER_TRIMMED_TYPE) {
      const source = this.getStore().get("source");
      for (let index in trimmed) {
        if (trimmed[index] && isGrouping(source[index])) {
          trimmed[index] = false;
        }
      }
    }
  }
  isSortingRunning() {
    const sortingPlugin = this.providers.plugins.getByClass(SortingPlugin);
    return !!(sortingPlugin === null || sortingPlugin === void 0 ? void 0 : sortingPlugin.sortingPromise);
  }
  /**
   * Starts global source update with group clearing and applying new one
   * Initiated when need to reapply grouping
   */
  doSourceUpdate(options) {
    var _a;
    const store = this.getStore();
    const { source, prevExpanded, oldNewIndexes } = getSource(store.get("source"), store.get("proxyItems"), true);
    const expanded = Object.assign({ prevExpanded }, options);
    const { sourceWithGroups, depth, trimmed, oldNewIndexMap } = gatherGrouping(source, ((_a = this.options) === null || _a === void 0 ? void 0 : _a.props) || [], expanded);
    const customRenderer = options === null || options === void 0 ? void 0 : options.groupLabelTemplate;
    this.providers.data.setData(sourceWithGroups, GROUPING_ROW_TYPE, this.revogrid.disableVirtualY, { depth, customRenderer }, true);
    this.updateTrimmed(trimmed, oldNewIndexes !== null && oldNewIndexes !== void 0 ? oldNewIndexes : {}, oldNewIndexMap);
  }
  /**
   * Apply grouping on data set
   * Clear grouping from source
   * If source came from other plugin
   */
  onDataSet(data) {
    var _a, _b;
    let preservedExpanded = {};
    if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.preserveGroupingOnUpdate) !== false) {
      let { prevExpanded } = getSource(this.getStore().get("source"), this.getStore().get("proxyItems"), true);
      preservedExpanded = prevExpanded;
    }
    const source = data.source.filter((s) => !isGrouping(s));
    const options = Object.assign(Object.assign({}, this.revogrid.grouping || {}), { prevExpanded: preservedExpanded });
    const { sourceWithGroups, depth, trimmed, oldNewIndexMap } = gatherGrouping(source, ((_b = this.options) === null || _b === void 0 ? void 0 : _b.props) || [], options);
    data.source = sourceWithGroups;
    this.providers.data.setGrouping({ depth });
    this.updateTrimmed(trimmed, oldNewIndexMap);
  }
  /**
   * External call to apply grouping. Called by revogrid when prop changed.
   */
  setGrouping(options) {
    var _a, _b;
    this.clearSubscriptions();
    this.options = options;
    if (!((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.length)) {
      this.clearGrouping();
      return;
    }
    const store = this.getStore();
    const { source } = getSource(store.get("source"), store.get("proxyItems"));
    if (source.length) {
      this.doSourceUpdate(Object.assign({}, options));
    }
    for (let t of columnTypes) {
      if (this.setColumnGrouping(this.providers.column.getColumns(t))) {
        this.providers.column.refreshByType(t);
        break;
      }
    }
    this.addEventListener("beforesourceset", ({ detail }) => {
      var _a2, _b2, _c;
      if (!(((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.props) === null || _b2 === void 0 ? void 0 : _b2.length) && ((_c = detail === null || detail === void 0 ? void 0 : detail.source) === null || _c === void 0 ? void 0 : _c.length))) {
        return;
      }
      if (this.isSortingRunning()) {
        return;
      }
      this.onDataSet(detail);
    });
    this.addEventListener("beforecolumnsset", ({ detail }) => {
      this.setColumns(detail);
    });
    this.addEventListener("beforetrimmed", ({ detail: { trimmed, trimmedType } }) => this.beforeTrimmedApply(trimmed, trimmedType));
    this.addEventListener("aftersortingapply", () => {
      var _a2, _b2;
      if (!((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.props) === null || _b2 === void 0 ? void 0 : _b2.length)) {
        return;
      }
      this.doSourceUpdate(Object.assign({}, this.options));
    });
    this.addEventListener("beforecellfocus", (e) => this.onFocus(e));
    this.addEventListener("roworderchanged", (e) => this.onDrag(e));
    this.addEventListener(GROUP_EXPAND_EVENT, (e) => this.onExpand(e.detail));
  }
  // clear grouping
  clearGrouping() {
    columnTypes.forEach((t) => {
      const cols = this.providers.column.getColumns(t);
      let deleted = false;
      cols.forEach((c) => {
        if (isGroupingColumn(c)) {
          delete c[PSEUDO_GROUP_COLUMN];
          deleted = true;
        }
      });
      if (deleted) {
        this.providers.column.refreshByType(t);
      }
    });
    const { source, oldNewIndexes } = getSource(this.getStore().get("source"), this.getStore().get("proxyItems"), true);
    this.providers.data.setData(source, GROUPING_ROW_TYPE, this.revogrid.disableVirtualY, void 0, true);
    this.updateTrimmed(void 0, void 0, oldNewIndexes);
  }
  updateTrimmed(trimmedGroup = {}, firstLevelMap = {}, secondLevelMap) {
    const trimemedOptionsToUpgrade = processDoubleConversionTrimmed(this.getStore().get("trimmed"), firstLevelMap, secondLevelMap);
    for (let type in trimemedOptionsToUpgrade) {
      this.revogrid.addTrimmed(trimemedOptionsToUpgrade[type], type);
    }
    this.revogrid.addTrimmed(Object.assign({}, trimmedGroup), TRIMMED_GROUPING);
  }
};
var COLUMN_DRAG_CLASS = "column-drag-start";
var ColumnOrderHandler = class {
  constructor() {
    this.offset = 0;
  }
  renderAutoscroll(_, parent) {
    if (!parent) {
      return;
    }
    this.autoscrollEl = document.createElement("div");
    this.autoscrollEl.classList.add("drag-auto-scroll-y");
    parent.appendChild(this.autoscrollEl);
  }
  autoscroll(pos, dataContainerSize, direction = "translateX") {
    if (!this.autoscrollEl) {
      return;
    }
    const helperOffset = 10;
    const maxScroll = Math.min(pos + helperOffset, dataContainerSize - 3);
    this.autoscrollEl.style.transform = `${direction}(${maxScroll}px)`;
    this.autoscrollEl.scrollIntoView({
      block: "nearest",
      inline: "nearest"
    });
  }
  start(e, { dataEl, gridRect, scrollEl, gridEl }, dir = "left") {
    gridEl.classList.add(COLUMN_DRAG_CLASS);
    const scrollContainerRect = scrollEl.getBoundingClientRect();
    if (scrollContainerRect) {
      this.offset = scrollContainerRect[dir] - gridRect[dir];
    }
    this.renderAutoscroll(e, dataEl);
  }
  stop(gridEl) {
    var _a;
    gridEl.classList.remove(COLUMN_DRAG_CLASS);
    if (this.element) {
      this.element.hidden = true;
    }
    this.offset = 0;
    (_a = this.autoscrollEl) === null || _a === void 0 ? void 0 : _a.remove();
    this.autoscrollEl = void 0;
  }
  showHandler(pos, size2, direction = "translateX") {
    if (!this.element) {
      return;
    }
    if (this.offset) {
      pos = Math.max(pos, this.offset);
    }
    pos = Math.min(pos, size2);
    this.element.style.transform = `${direction}(${pos}px)`;
    this.element.hidden = false;
  }
  render() {
    const el = this.element = document.createElement("div");
    el.classList.add("drag-position-y");
    el.hidden = true;
    return el;
  }
};
var COLUMN_CLICK = ON_COLUMN_CLICK;
var MOVE = "columndragmousemove";
var DRAG_END = "columndragend";
var BEFORE_DRAG_END = "beforecolumndragend";
var DRAG_START = "columndragstart";
var ColumnMovePlugin = class extends BasePlugin {
  constructor(revogrid, providers) {
    super(revogrid, providers);
    this.moveFunc = debounce((e) => this.doMove(e), 5);
    this.staticDragData = null;
    this.dragData = null;
    this.localSubscriptions = {};
    this.orderUi = new ColumnOrderHandler();
    revogrid.appendChild(this.orderUi.render());
    revogrid.classList.add("column-draggable");
    this.localSubscriptions["mouseleave"] = {
      target: document,
      callback: (e) => this.onMouseOut(e)
    };
    this.localSubscriptions["mouseup"] = {
      target: document,
      callback: (e) => this.onMouseUp(e)
    };
    this.localSubscriptions["mousemove"] = {
      target: document,
      callback: (e) => this.move(e)
    };
    this.addEventListener(COLUMN_CLICK, ({ detail }) => this.dragStart(detail));
  }
  dragStart({ event, data }) {
    if (event.defaultPrevented) {
      return;
    }
    const { defaultPrevented } = dispatch(this.revogrid, DRAG_START, data);
    if (defaultPrevented) {
      return;
    }
    this.clearOrder();
    const { mouseleave, mouseup, mousemove } = this.localSubscriptions;
    mouseleave.target.addEventListener("mouseleave", mouseleave.callback);
    mouseup.target.addEventListener("mouseup", mouseup.callback);
    const dataEl = event.target.closest("revogr-header");
    const scrollEl = event.target.closest("revogr-viewport-scroll");
    if (!dataEl || !scrollEl) {
      return;
    }
    if (isColGrouping(data) || data.providers.type === "rowHeaders") {
      return;
    }
    const cols = this.getDimension(data.pin || "rgCol");
    const gridRect = this.revogrid.getBoundingClientRect();
    const elRect = dataEl.getBoundingClientRect();
    const startItem = getItemByPosition(cols, getLeftRelative(event.x, gridRect.left, elRect.left - gridRect.left));
    this.staticDragData = {
      startPos: event.x,
      startItem,
      pin: data.pin,
      dataEl,
      scrollEl,
      gridEl: this.revogrid,
      cols
    };
    this.dragData = this.getData(this.staticDragData);
    mousemove.target.addEventListener("mousemove", mousemove.callback);
    this.orderUi.start(event, Object.assign(Object.assign({}, this.dragData), this.staticDragData));
  }
  doMove(e) {
    if (!this.staticDragData) {
      return;
    }
    const dragData = this.dragData = this.getData(this.staticDragData);
    if (!dragData) {
      return;
    }
    const start = this.staticDragData.startPos;
    if (Math.abs(start - e.x) > 10) {
      const x = getLeftRelative(e.x, this.dragData.gridRect.left, this.dragData.scrollOffset);
      const rgCol = getItemByPosition(this.staticDragData.cols, x);
      this.orderUi.autoscroll(x, dragData.elRect.width);
      if (rgCol.itemIndex >= this.staticDragData.cols.count) {
        return;
      }
      this.orderUi.showHandler(rgCol.end + dragData.scrollOffset, dragData.gridRect.width);
    }
  }
  move(e) {
    dispatch(this.revogrid, MOVE, e);
    this.moveFunc(e);
  }
  onMouseOut(_) {
    this.clearOrder();
  }
  onMouseUp(e) {
    if (this.dragData && this.staticDragData) {
      let relativePos = getLeftRelative(e.x, this.dragData.gridRect.left, this.dragData.scrollOffset);
      if (relativePos < 0) {
        relativePos = 0;
      }
      const newPosition = getItemByPosition(this.staticDragData.cols, relativePos);
      const store = this.providers.column.stores[this.dragData.type].store;
      const newItems = [...store.get("items")];
      const { defaultPrevented: stopDrag } = dispatch(this.revogrid, BEFORE_DRAG_END, Object.assign(Object.assign({}, this.staticDragData), { startPosition: this.staticDragData.startItem, newPosition, newItem: store.get("source")[newItems[this.staticDragData.startItem.itemIndex]] }));
      if (!stopDrag) {
        const prevItems = [...newItems];
        const toMove = newItems.splice(this.staticDragData.startItem.itemIndex, 1);
        newItems.splice(newPosition.itemIndex, 0, ...toMove);
        store.set("items", newItems);
        this.providers.dimension.updateSizesPositionByNewDataIndexes(this.dragData.type, newItems, prevItems);
      }
      dispatch(this.revogrid, DRAG_END, this.dragData);
    }
    this.clearOrder();
  }
  clearLocalSubscriptions() {
    forEach(this.localSubscriptions, ({ target, callback }, key) => target.removeEventListener(key, callback));
  }
  clearOrder() {
    this.staticDragData = null;
    this.dragData = null;
    this.clearLocalSubscriptions();
    this.orderUi.stop(this.revogrid);
  }
  /**
   * Clearing subscription
   */
  clearSubscriptions() {
    super.clearSubscriptions();
    this.clearLocalSubscriptions();
  }
  getData({ gridEl, dataEl, pin }) {
    const gridRect = gridEl.getBoundingClientRect();
    const elRect = dataEl.getBoundingClientRect();
    const scrollOffset = elRect.left - gridRect.left;
    return {
      elRect,
      gridRect,
      type: pin || "rgCol",
      scrollOffset
    };
  }
  getDimension(type) {
    return this.providers.dimension.stores[type].getCurrentState();
  }
};
function getLeftRelative(absoluteX, gridPos, offset) {
  return absoluteX - gridPos - offset;
}

// node_modules/@revolist/revogrid/dist/esm/revo-grid.entry.js
var ThemeCompact = class {
  constructor() {
    this.defaultRowSize = 32;
  }
};
var ThemeDefault = class {
  constructor() {
    this.defaultRowSize = 27;
  }
};
var ThemeMaterial = class {
  constructor() {
    this.defaultRowSize = 42;
  }
};
var DEFAULT_THEME = "default";
var allowedThemes = [
  DEFAULT_THEME,
  "material",
  "compact",
  "darkMaterial",
  "darkCompact"
];
var ThemeService = class {
  get theme() {
    return this.currentTheme;
  }
  get rowSize() {
    return this.customRowSize || this.currentTheme.defaultRowSize;
  }
  set rowSize(size2) {
    this.customRowSize = size2;
  }
  constructor(cfg) {
    this.customRowSize = 0;
    this.customRowSize = cfg.rowSize;
    this.register("default");
  }
  register(theme) {
    const parsedTheme = getTheme(theme);
    switch (parsedTheme) {
      case "material":
      case "darkMaterial":
        this.currentTheme = new ThemeMaterial();
        break;
      case "compact":
      case "darkCompact":
        this.currentTheme = new ThemeCompact();
        break;
      default:
        this.currentTheme = new ThemeDefault();
        break;
    }
  }
};
function getTheme(theme) {
  if (theme && allowedThemes.indexOf(theme) > -1) {
    return theme;
  }
  return DEFAULT_THEME;
}
var ColumnDataProvider = class {
  get stores() {
    return this.dataSources;
  }
  constructor() {
    this.collection = null;
    this.dataSources = columnTypes.reduce((sources, k) => {
      sources[k] = new DataStore(k);
      return sources;
    }, {});
  }
  column(c, type = "rgCol") {
    return this.getColumn(c, type);
  }
  getColumn(virtualIndex, type) {
    return getSourceItem(this.dataSources[type].store, virtualIndex);
  }
  getRawColumns() {
    return reduce(this.dataSources, (result, item, type) => {
      result[type] = item.store.get("source");
      return result;
    }, {
      rgCol: [],
      colPinStart: [],
      colPinEnd: []
    });
  }
  getColumns(type = "all") {
    const columnsByType = this.getRawColumns();
    if (type !== "all") {
      return columnsByType[type];
    }
    return columnTypes.reduce((r, t) => [...r, ...columnsByType[t]], []);
  }
  getColumnIndexByProp(prop, type) {
    return getSourceItemVirtualIndexByProp(this.dataSources[type].store, prop);
  }
  getColumnByProp(prop) {
    var _a;
    return (_a = this.collection) === null || _a === void 0 ? void 0 : _a.columnByProp[prop];
  }
  refreshByType(type) {
    this.dataSources[type].refresh();
  }
  /**
   * Main method to set columns
   */
  setColumns(data) {
    columnTypes.forEach((k) => {
      this.dataSources[k].updateData(data.columns[k], {
        // max depth level
        depth: data.maxLevel,
        // groups
        groups: data.columnGrouping[k].reduce((res, g) => {
          if (!res[g.level]) {
            res[g.level] = [];
          }
          res[g.level].push(g);
          return res;
        }, {})
      });
    });
    this.collection = data;
    return data;
  }
  /**
   * Used in plugins
   * Modify columns in store
   */
  updateColumns(updatedColumns) {
    const columnByKey = updatedColumns.reduce((res, c) => {
      const type = getColumnType(c);
      if (!res[type]) {
        res[type] = {};
      }
      res[type][c.prop] = c;
      return res;
    }, {});
    const colByIndex = {};
    for (const t in columnByKey) {
      if (!columnByKey.hasOwnProperty(t)) {
        continue;
      }
      const type = t;
      const colsToUpdate = columnByKey[type];
      const sourceItems = this.dataSources[type].store.get("source");
      colByIndex[type] = {};
      for (let i = 0; i < sourceItems.length; i++) {
        const column = sourceItems[i];
        const colToUpdateIfExists = colsToUpdate === null || colsToUpdate === void 0 ? void 0 : colsToUpdate[column.prop];
        if (colToUpdateIfExists) {
          colByIndex[type][i] = colToUpdateIfExists;
        }
      }
    }
    for (const t in colByIndex) {
      if (!colByIndex.hasOwnProperty(t)) {
        continue;
      }
      const type = t;
      setSourceByPhysicalIndex(this.dataSources[type].store, colByIndex[type] || {});
    }
  }
  updateColumn(column, index) {
    const type = getColumnType(column);
    setSourceByVirtualIndex(this.dataSources[type].store, { [index]: column });
  }
};
var DataProvider = class {
  constructor(dimensionProvider) {
    this.dimensionProvider = dimensionProvider;
    this.stores = reduce(rowTypes, (sources, k) => {
      sources[k] = new DataStore(k);
      return sources;
    }, {});
  }
  setData(data, type = "rgRow", disableVirtualRows = false, grouping, silent = false) {
    this.stores[type].updateData([...data], grouping, silent);
    const noVirtual = type !== "rgRow" || disableVirtualRows;
    this.dimensionProvider.setData(data.length, type, noVirtual);
    return data;
  }
  getModel(virtualIndex, type = "rgRow") {
    const store = this.stores[type].store;
    return getSourceItem(store, virtualIndex);
  }
  changeOrder({ rowType = "rgRow", from, to }) {
    const storeService = this.stores[rowType];
    const newItemsOrder = [...storeService.store.get("proxyItems")];
    const prevItems = storeService.store.get("items");
    const toMove = newItemsOrder.splice(
      newItemsOrder.indexOf(prevItems[from]),
      // get index in proxy
      1
    );
    newItemsOrder.splice(
      newItemsOrder.indexOf(prevItems[to]),
      // get index in proxy
      0,
      ...toMove
    );
    storeService.setData({
      proxyItems: newItemsOrder
    });
    const newItems = storeService.store.get("items");
    this.dimensionProvider.updateSizesPositionByNewDataIndexes(rowType, newItems, prevItems);
  }
  setCellData({ type, rowIndex, prop, val }, mutate = true) {
    const model = this.getModel(rowIndex, type);
    model[prop] = val;
    this.stores[type].setSourceData({ [rowIndex]: model }, mutate);
  }
  setRangeData(data, type) {
    const items = {};
    for (let rowIndex in data) {
      const oldModel = items[rowIndex] = getSourceItem(this.stores[type].store, parseInt(rowIndex, 10));
      if (!oldModel) {
        continue;
      }
      for (let prop in data[rowIndex]) {
        oldModel[prop] = data[rowIndex][prop];
      }
    }
    this.stores[type].setSourceData(items);
  }
  refresh(type = "all") {
    if (isRowType(type)) {
      this.refreshItems(type);
    }
    rowTypes.forEach((t) => this.refreshItems(t));
  }
  refreshItems(type = "rgRow") {
    const items = this.stores[type].store.get("items");
    this.stores[type].setData({ items: [...items] });
  }
  setGrouping({ depth }, type = "rgRow") {
    this.stores[type].setData({ groupingDepth: depth });
  }
  setTrimmed(trimmed, type = "rgRow") {
    const store = this.stores[type];
    store.addTrimmed(trimmed);
    this.dimensionProvider.setTrimmed(trimmed, type);
    if (type === "rgRow") {
      this.dimensionProvider.setData(getVisibleSourceItem(store.store).length, type);
    }
  }
};
var DimensionProvider = class {
  constructor(viewports, config) {
    this.viewports = viewports;
    const sizeChanged = debounce((k) => config.realSizeChanged(k), RESIZE_INTERVAL);
    this.stores = reduce([...rowTypes, ...columnTypes], (sources, t) => {
      sources[t] = new DimensionStore(t);
      sources[t].store.onChange("realSize", () => sizeChanged(t));
      return sources;
    }, {});
  }
  /**
   * Clear old sizes from dimension and viewports
   * @param type - dimension type
   * @param count - count of items
   */
  clearSize(t, count) {
    this.stores[t].drop();
    this.viewports.stores[t].setOriginalSizes(this.stores[t].store.get("originItemSize"));
    this.setItemCount(count, t);
  }
  /**
   * Apply new custom sizes to dimension and view port
   * @param type - dimension type
   * @param sizes - new custom sizes
   * @param keepOld - keep old sizes merge new with old
   */
  setCustomSizes(type, sizes, keepOld = false) {
    let newSizes = sizes;
    if (keepOld) {
      const oldSizes = this.stores[type].store.get("sizes");
      newSizes = Object.assign(Object.assign({}, oldSizes), sizes);
    }
    this.stores[type].setDimensionSize(newSizes);
    this.setViewPortCoordinate({
      type,
      force: true
    });
  }
  setItemCount(realCount, type) {
    this.viewports.stores[type].setViewport({ realCount });
    this.stores[type].setStore({ count: realCount });
  }
  /**
   * Apply trimmed items
   * @param trimmed - trimmed items
   * @param type
   */
  setTrimmed(trimmed, type) {
    const allTrimmed = gatherTrimmedItems(trimmed);
    const dimStoreType = this.stores[type];
    dimStoreType.setStore({ trimmed: allTrimmed });
    this.setViewPortCoordinate({
      type,
      force: true
    });
  }
  /**
   * Sets dimension data and viewport coordinate
   * @param itemCount
   * @param type - dimension type
   * @param noVirtual - disable virtual data
   */
  setData(itemCount, type, noVirtual = false) {
    this.setItemCount(itemCount, type);
    if (noVirtual) {
      const dimension = this.stores[type].getCurrentState();
      this.viewports.stores[type].setViewport({
        virtualSize: dimension.realSize
      });
    }
    this.setViewPortCoordinate({
      type
    });
  }
  /**
   * Applies new columns to the dimension provider
   * @param columns - new columns data
   * @param disableVirtualX - disable virtual data for X axis
   */
  applyNewColumns(columns, disableVirtualX, keepOld = false) {
    for (let type of columnTypes) {
      if (!keepOld) {
        this.stores[type].drop();
      }
      const items = columns[type];
      const noVirtual = type !== "rgCol" || disableVirtualX;
      this.stores[type].setStore({ count: items.length });
      const newSizes = getColumnSizes(items);
      this.stores[type].setDimensionSize(newSizes);
      const vpUpdate = {
        // This triggers drop on realCount change
        realCount: items.length
      };
      if (noVirtual) {
        vpUpdate.virtualSize = this.stores[type].getCurrentState().realSize;
      }
      this.viewports.stores[type].setViewport(vpUpdate);
      this.setViewPortCoordinate({
        type
      });
    }
  }
  /**
   * Gets the full size of the grid by summing up the sizes of all dimensions
   * Goes through all dimensions columnTypes (x) and rowTypes (y) and sums up their sizes
   */
  getFullSize() {
    var _a, _b;
    let x = 0;
    let y = 0;
    for (let type of columnTypes) {
      x += ((_a = this.stores[type]) === null || _a === void 0 ? void 0 : _a.store.get("realSize")) || 0;
    }
    for (let type of rowTypes) {
      y += ((_b = this.stores[type]) === null || _b === void 0 ? void 0 : _b.store.get("realSize")) || 0;
    }
    return { y, x };
  }
  setViewPortCoordinate({ type, coordinate = this.viewports.stores[type].lastCoordinate, force = false }) {
    const dimension = this.stores[type].getCurrentState();
    this.viewports.stores[type].setViewPortCoordinate(coordinate, dimension, force);
  }
  getViewPortPos(e) {
    const dimension = this.stores[e.dimension].getCurrentState();
    const item = getItemByIndex(dimension, e.coordinate);
    return item.start;
  }
  setSettings(data, dimensionType) {
    let stores = [];
    switch (dimensionType) {
      case "rgCol":
        stores = columnTypes;
        break;
      case "rgRow":
        stores = rowTypes;
        break;
    }
    for (let s of stores) {
      this.stores[s].setStore(data);
    }
  }
  updateSizesPositionByNewDataIndexes(type, newItemsOrder, prevItemsOrder = []) {
    this.stores[type].updateSizesPositionByIndexes(newItemsOrder, prevItemsOrder);
    this.setViewPortCoordinate({
      type,
      force: true
    });
  }
};
var ViewportProvider = class {
  constructor() {
    this.stores = reduce([...rowTypes, ...columnTypes], (sources, k) => {
      sources[k] = new ViewportStore(k);
      return sources;
    }, {});
  }
  setViewport(type, data) {
    this.stores[type].setViewport(data);
  }
};
function gatherColumnData(data) {
  const colDimension = data.dimensions[data.colType].store;
  const realWidth = colDimension.get("realSize");
  const prop = {
    contentWidth: realWidth,
    class: data.colType,
    contentHeight: data.contentHeight,
    key: data.colType,
    colType: data.colType,
    onResizeviewport: data.onResizeviewport,
    // set viewport size to real size
    style: data.fixWidth ? { minWidth: `${realWidth}px` } : void 0
  };
  const headerProp = {
    colData: getVisibleSourceItem(data.colStore),
    dimensionCol: colDimension,
    type: data.colType,
    groups: data.colStore.get("groups"),
    groupingDepth: data.colStore.get("groupingDepth"),
    resizeHandler: data.colType === "colPinEnd" ? ["l"] : void 0,
    onHeaderresize: data.onHeaderresize
  };
  return {
    prop,
    type: data.colType,
    position: data.position,
    headerProp,
    viewportCol: data.viewports[data.colType].store
  };
}
var ViewportService = class {
  constructor(config, contentHeight) {
    var _a;
    this.config = config;
    const columns = [];
    let x = 0;
    columnTypes.forEach((val) => {
      const colStore = config.columnProvider.stores[val].store;
      if (!colStore.get("items").length) {
        return;
      }
      const column = {
        colType: val,
        position: { x, y: 1 },
        contentHeight,
        // only central column has dynamic width
        fixWidth: val !== "rgCol",
        viewports: config.viewportProvider.stores,
        dimensions: config.dimensionProvider.stores,
        rowStores: config.dataProvider.stores,
        colStore,
        onHeaderresize: (e) => this.onColumnResize(val, e, colStore)
      };
      if (val === "rgCol") {
        column.onResizeviewport = (e) => {
          var _a2;
          const vpState = {
            clientSize: e.detail.size
          };
          if (e.detail.dimension === "rgRow" && !config.disableVirtualY || e.detail.dimension === "rgCol" && !config.disableVirtualX) {
            vpState.virtualSize = e.detail.size;
          }
          (_a2 = config.viewportProvider) === null || _a2 === void 0 ? void 0 : _a2.setViewport(e.detail.dimension, vpState);
        };
      }
      const colData = gatherColumnData(column);
      const columnSelectionStore = this.registerCol(colData.position.x, val);
      const dataPorts = this.dataViewPort(column).reduce((r, rgRow) => {
        const segmentSelection = this.registerSegment(rgRow.position, rgRow.lastCell);
        const rowSelectionStore = this.registerRow(rgRow.position.y, rgRow.type);
        const rowDef = Object.assign(Object.assign({ colType: val }, rgRow), { rowSelectionStore, selectionStore: segmentSelection.store, onSetrange: (e) => {
          segmentSelection.setRangeArea(e.detail);
        }, onSettemprange: (e) => segmentSelection.setTempArea(e.detail), onFocuscell: (e) => {
          segmentSelection.clearFocus();
          config.selectionStoreConnector.focus(segmentSelection, e.detail);
        } });
        r.push(rowDef);
        return r;
      }, []);
      columns.push(Object.assign(Object.assign({}, colData), {
        columnSelectionStore,
        dataPorts
      }));
      x++;
    });
    this.columns = columns;
    (_a = this.config.scrollingService) === null || _a === void 0 ? void 0 : _a.unregister();
  }
  onColumnResize(type, { detail }, store) {
    var _a;
    (_a = this.config.dimensionProvider) === null || _a === void 0 ? void 0 : _a.setCustomSizes(type, detail, true);
    const changedItems = {};
    for (const [i, size2] of Object.entries(detail || {})) {
      const virtualIndex = parseInt(i, 10);
      const item = getSourceItem(store, virtualIndex);
      if (item) {
        changedItems[virtualIndex] = Object.assign(Object.assign({}, item), { size: size2 });
      }
    }
    this.config.resize(changedItems);
  }
  /** register selection store for Segment */
  registerSegment(position, lastCell) {
    const store = this.config.selectionStoreConnector.register(position);
    store.setLastCell(lastCell);
    return store;
  }
  /** register selection store for Row */
  registerRow(y, type) {
    return this.config.selectionStoreConnector.registerRow(y, type).store;
  }
  /** register selection store for Column */
  registerCol(x, type) {
    return this.config.selectionStoreConnector.registerColumn(x, type).store;
  }
  /** Collect Row data */
  dataViewPort(data) {
    const slots = {
      rowPinStart: HEADER_SLOT,
      rgRow: CONTENT_SLOT,
      rowPinEnd: FOOTER_SLOT
    };
    let y = 0;
    return rowTypes.reduce((result, type) => {
      const rgCol = Object.assign(Object.assign({}, data), { position: Object.assign(Object.assign({}, data.position), { y }) });
      const partition = viewportDataPartition(rgCol, type, slots[type], type !== "rgRow");
      result.push(partition);
      y++;
      return result;
    }, []);
  }
  scrollToCell(cell) {
    for (let key in cell) {
      const coordinate = cell[key];
      if (typeof coordinate === "number") {
        this.config.scrollingService.proxyScroll({
          dimension: key === "x" ? "rgCol" : "rgRow",
          coordinate
        });
      }
    }
  }
  /**
   * Clear current grid focus
   */
  clearFocused() {
    this.config.selectionStoreConnector.clearAll();
  }
  clearEdit() {
    this.config.selectionStoreConnector.setEdit(false);
  }
  /**
   * Collect focused element data
   */
  getFocused() {
    const focused = this.config.selectionStoreConnector.focusedStore;
    if (!focused) {
      return null;
    }
    const colType = this.config.selectionStoreConnector.storesXToType[focused.position.x];
    const column = this.config.columnProvider.getColumn(focused.cell.x, colType);
    const rowType = this.config.selectionStoreConnector.storesYToType[focused.position.y];
    const model = this.config.dataProvider.getModel(focused.cell.y, rowType);
    return {
      column,
      model,
      cell: focused.cell,
      colType,
      rowType
    };
  }
  getStoreCoordinateByType(colType, rowType) {
    const stores = this.config.selectionStoreConnector.storesByType;
    if (typeof stores[colType] === "undefined" || typeof stores[rowType] === "undefined") {
      return;
    }
    return {
      x: stores[colType],
      y: stores[rowType]
    };
  }
  setFocus(colType, rowType, start, end) {
    var _a;
    const coordinate = this.getStoreCoordinateByType(colType, rowType);
    if (coordinate) {
      (_a = this.config.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.focusByCell(coordinate, start, end);
    }
  }
  getSelectedRange() {
    const focused = this.config.selectionStoreConnector.focusedStore;
    if (!focused) {
      return null;
    }
    const colType = this.config.selectionStoreConnector.storesXToType[focused.position.x];
    const rowType = this.config.selectionStoreConnector.storesYToType[focused.position.y];
    const range = focused.entity.store.get("range");
    if (!range) {
      return null;
    }
    return Object.assign(Object.assign({}, range), {
      colType,
      rowType
    });
  }
  setEdit(rowIndex, colIndex, colType, rowType) {
    var _a;
    const coordinate = this.getStoreCoordinateByType(colType, rowType);
    if (coordinate) {
      (_a = this.config.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.setEditByCell(coordinate, { x: colIndex, y: rowIndex });
    }
  }
};
var GridScrollingService = class {
  constructor(setViewport) {
    this.setViewport = setViewport;
    this.elements = {};
  }
  async proxyScroll(e, key) {
    var _a;
    let newEventPromise;
    let event = e;
    for (let elKey in this.elements) {
      if (e.dimension === "rgCol" && elKey === "headerRow") {
        continue;
      } else if (this.isPinnedColumn(key) && e.dimension === "rgCol") {
        if (elKey === key || !e.delta) {
          continue;
        }
        for (let el of this.elements[elKey]) {
          if (el.changeScroll) {
            newEventPromise = el.changeScroll(e);
          }
        }
      } else {
        for (let el of this.elements[elKey]) {
          await ((_a = el.setScroll) === null || _a === void 0 ? void 0 : _a.call(el, e));
        }
      }
    }
    const newEvent = await newEventPromise;
    if (newEvent) {
      event = newEvent;
    }
    this.setViewport(event);
  }
  /**
   * Silent scroll update for mobile devices when we have negative scroll top
   */
  async scrollSilentService(e, key) {
    var _a;
    for (let elKey in this.elements) {
      if (elKey === key) {
        continue;
      }
      if (columnTypes.includes(key) && (elKey === "headerRow" || columnTypes.includes(elKey))) {
        for (let el of this.elements[elKey]) {
          await ((_a = el.changeScroll) === null || _a === void 0 ? void 0 : _a.call(el, e, true));
        }
        continue;
      }
    }
  }
  isPinnedColumn(key) {
    return !!key && ["colPinStart", "colPinEnd"].indexOf(key) > -1;
  }
  registerElements(els) {
    this.elements = els;
  }
  /**
   * Register new element for farther scroll support
   * @param el - can be null if holder removed
   * @param key - element key
   */
  registerElement(el, key) {
    if (!this.elements[key]) {
      this.elements[key] = [];
    }
    if (el) {
      this.elements[key].push(el);
    } else if (this.elements[key]) {
      delete this.elements[key];
    }
  }
  unregister() {
    this.elements = {};
  }
};
var SelectionStoreConnector = class {
  constructor() {
    this.stores = {};
    this.columnStores = {};
    this.rowStores = {};
    this.storesByType = {};
    this.storesXToType = {};
    this.storesYToType = {};
  }
  get focusedStore() {
    var _a;
    for (let y in this.stores) {
      for (let x in this.stores[y]) {
        const focused = (_a = this.stores[y][x]) === null || _a === void 0 ? void 0 : _a.store.get("focus");
        if (focused) {
          return {
            entity: this.stores[y][x],
            cell: focused,
            position: {
              x: parseInt(x, 10),
              y: parseInt(y, 10)
            }
          };
        }
      }
    }
    return null;
  }
  get edit() {
    var _a;
    return (_a = this.focusedStore) === null || _a === void 0 ? void 0 : _a.entity.store.get("edit");
  }
  get focused() {
    var _a;
    return (_a = this.focusedStore) === null || _a === void 0 ? void 0 : _a.entity.store.get("focus");
  }
  get selectedRange() {
    var _a;
    return (_a = this.focusedStore) === null || _a === void 0 ? void 0 : _a.entity.store.get("range");
  }
  registerColumn(x, type) {
    if (this.columnStores[x]) {
      return this.columnStores[x];
    }
    this.columnStores[x] = new SelectionStore();
    this.storesByType[type] = x;
    this.storesXToType[x] = type;
    return this.columnStores[x];
  }
  registerRow(y, type) {
    if (this.rowStores[y]) {
      return this.rowStores[y];
    }
    this.rowStores[y] = new SelectionStore();
    this.storesByType[type] = y;
    this.storesYToType[y] = type;
    return this.rowStores[y];
  }
  /**
   * Cross store proxy, based on multiple dimensions
   */
  register({ x, y }) {
    if (!this.stores[y]) {
      this.stores[y] = {};
    }
    let store = this.stores[y][x];
    if (store) {
      return store;
    }
    this.stores[y][x] = store = new SelectionStore();
    store.onChange("range", (c) => {
      this.columnStores[x].setRangeArea(c);
      this.rowStores[y].setRangeArea(c);
    });
    store.store.on("dispose", () => this.destroy(x, y));
    return store;
  }
  destroy(x, y) {
    var _a, _b;
    (_a = this.columnStores[x]) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this.rowStores[y]) === null || _b === void 0 ? void 0 : _b.dispose();
    delete this.rowStores[y];
    delete this.columnStores[x];
    if (this.storesXToType[x]) {
      const type = this.storesXToType[x];
      delete this.storesXToType[x];
      delete this.storesByType[type];
    }
    if (this.storesYToType[y]) {
      const type = this.storesYToType[y];
      delete this.storesYToType[y];
      delete this.storesByType[type];
    }
    if (this.stores[y]) {
      delete this.stores[y][x];
    }
    if (!Object.keys(this.stores[y] || {}).length) {
      delete this.stores[y];
    }
  }
  setEditByCell(storePos, editCell) {
    this.focusByCell(storePos, editCell, editCell);
    this.setEdit("");
  }
  /**
   * Sets the next focus cell before the current one.
   *
   * @param focus - The cell to set as the next focus.
   */
  beforeNextFocusCell(focus) {
    var _a;
    if (!this.focusedStore) {
      return;
    }
    const lastCell = this.focusedStore.entity.store.get("lastCell");
    const next = lastCell && this.getNextStore(focus, this.focusedStore.position, lastCell);
    (_a = next === null || next === void 0 ? void 0 : next.store) === null || _a === void 0 ? void 0 : _a.setNextFocus(Object.assign(Object.assign({}, focus), next.item));
  }
  focusByCell(storePos, start, end) {
    const store = this.stores[storePos.y][storePos.x];
    this.focus(store, { focus: start, end });
  }
  focus(store, { focus, end }) {
    const currentStorePointer = this.getCurrentStorePointer(store);
    if (!currentStorePointer) {
      return null;
    }
    const lastCell = store.store.get("lastCell");
    const next = lastCell && this.getNextStore(focus, currentStorePointer, lastCell);
    if (next === null || next === void 0 ? void 0 : next.store) {
      const item = Object.assign(Object.assign({}, focus), next.item);
      this.focus(next.store, { focus: item, end: item });
      return null;
    }
    if (lastCell) {
      focus = cropCellToMax(focus, lastCell);
      end = cropCellToMax(end, lastCell);
    }
    store.setFocus(focus, end);
    return focus;
  }
  /**
   * Retrieves the current store pointer based on the active store.
   * Clears focus from all stores except the active one.
   */
  getCurrentStorePointer(store) {
    let currentStorePointer;
    for (let y in this.stores) {
      for (let x in this.stores[y]) {
        const s = this.stores[y][x];
        if (s !== store) {
          s.clearFocus();
        } else {
          currentStorePointer = {
            x: parseInt(x, 10),
            y: parseInt(y, 10)
          };
        }
      }
    }
    return currentStorePointer;
  }
  /**
   * Retrieves the next store based on the focus cell and current store pointer.
   * If the next store exists, returns an object with the next store and the item in the new store.
   * If the next store does not exist, returns null.
   */
  getNextStore(focus, currentStorePointer, lastCell) {
    const nextItem = nextCell(focus, lastCell);
    let nextStore;
    if (nextItem) {
      Object.entries(nextItem).forEach(([type, nextItemCoord]) => {
        let stores;
        switch (type) {
          case "x":
            stores = this.getXStores(currentStorePointer.y);
            break;
          case "y":
            stores = this.getYStores(currentStorePointer.x);
            break;
        }
        if (nextItemCoord >= 0) {
          nextStore = stores[++currentStorePointer[type]];
        } else {
          nextStore = stores[--currentStorePointer[type]];
          const nextLastCell = nextStore === null || nextStore === void 0 ? void 0 : nextStore.store.get("lastCell");
          if (nextLastCell) {
            nextItem[type] = nextLastCell[type] + nextItemCoord;
          }
        }
      });
    }
    const lastCellNext = nextStore === null || nextStore === void 0 ? void 0 : nextStore.store.get("lastCell");
    if (!(lastCellNext === null || lastCellNext === void 0 ? void 0 : lastCellNext.x) || !(lastCellNext === null || lastCellNext === void 0 ? void 0 : lastCellNext.y)) {
      nextStore = void 0;
    }
    return {
      store: nextStore,
      item: nextItem
    };
  }
  clearAll() {
    var _a;
    for (let y in this.stores) {
      for (let x in this.stores[y]) {
        (_a = this.stores[y][x]) === null || _a === void 0 ? void 0 : _a.clearFocus();
      }
    }
  }
  setEdit(val) {
    if (!this.focusedStore) {
      return;
    }
    this.focusedStore.entity.setEdit(val);
  }
  /**
   * Select all cells across all stores
   */
  selectAll() {
    for (let y in this.stores) {
      for (let x in this.stores[y]) {
        const store = this.stores[y][x];
        if (!store) {
          continue;
        }
        const lastCell = store.store.get("lastCell");
        if (lastCell) {
          store.setRange({ x: 0, y: 0 }, { x: lastCell.x - 1, y: lastCell.y - 1 });
        }
      }
    }
  }
  getXStores(y) {
    return this.stores[y];
  }
  getYStores(x) {
    const stores = {};
    for (let i in this.stores) {
      stores[i] = this.stores[i][x];
    }
    return stores;
  }
};
var OrdererService = class {
  constructor() {
    this.parentY = 0;
  }
  start(parent, { pos, text, event }) {
    var _a;
    const { top } = parent.getBoundingClientRect();
    this.parentY = top;
    if (this.text) {
      this.text.innerText = text;
    }
    this.move(pos);
    this.moveTip({ x: event.x, y: event.y });
    (_a = this.el) === null || _a === void 0 ? void 0 : _a.classList.remove("hidden");
  }
  end() {
    var _a;
    (_a = this.el) === null || _a === void 0 ? void 0 : _a.classList.add("hidden");
  }
  move(pos) {
    this.moveElement(pos.end - this.parentY);
  }
  moveTip({ x, y }) {
    if (!this.draggable) {
      return;
    }
    this.draggable.style.left = `${x}px`;
    this.draggable.style.top = `${y}px`;
  }
  moveElement(y) {
    if (!this.rgRow) {
      return;
    }
    this.rgRow.style.transform = `translateY(${y}px)`;
  }
};
var OrderRenderer = ({ ref }) => {
  const service = new OrdererService();
  ref(service);
  return h(
    "div",
    { class: "draggable-wrapper hidden", ref: (e) => service.el = e },
    h(
      "div",
      { class: "draggable", ref: (el) => service.draggable = el },
      h("span", { class: "revo-alt-icon" }),
      h("span", { ref: (e) => service.text = e })
    ),
    h("div", { class: "drag-position", ref: (e) => service.rgRow = e })
  );
};
var rowDefinitionByType = (newVal = []) => {
  const result = {};
  for (const v of newVal) {
    let rowDefs = result[v.type];
    if (!rowDefs) {
      rowDefs = result[v.type] = {};
    }
    if (v.size) {
      if (!rowDefs.sizes) {
        rowDefs.sizes = {};
      }
      rowDefs.sizes[v.index] = v.size;
    }
  }
  return result;
};
var rowDefinitionRemoveByType = (oldVal = []) => {
  const result = {};
  for (const v of oldVal) {
    let rowDefs = result[v.type];
    if (!rowDefs) {
      rowDefs = result[v.type] = [];
    }
    if (v.size) {
      rowDefs.push(v.index);
    }
  }
  return result;
};
function isMobileDevice() {
  return /Mobi/i.test(navigator.userAgent) || /Android/i.test(navigator.userAgent) || navigator.maxTouchPoints > 0;
}
var WCAGPlugin = class extends BasePlugin {
  constructor(revogrid, providers) {
    super(revogrid, providers);
    revogrid.setAttribute("role", "treegrid");
    revogrid.setAttribute("aria-keyshortcuts", "Enter");
    revogrid.setAttribute("aria-multiselectable", "true");
    revogrid.setAttribute("tabindex", "0");
    this.addEventListener("beforecolumnsset", ({ detail }) => {
      const columns = [
        ...detail.columns.colPinStart,
        ...detail.columns.rgCol,
        ...detail.columns.colPinEnd
      ];
      revogrid.setAttribute("aria-colcount", `${columns.length}`);
      columns.forEach((column, index) => {
        const { columnProperties, cellProperties } = column;
        column.columnProperties = (...args) => {
          const result = (columnProperties === null || columnProperties === void 0 ? void 0 : columnProperties(...args)) || {};
          result.role = "columnheader";
          result["aria-colindex"] = `${index}`;
          return result;
        };
        column.cellProperties = (...args) => {
          const wcagProps = {
            ["role"]: "gridcell",
            ["aria-colindex"]: `${index}`,
            ["aria-rowindex"]: `${args[0].rowIndex}`,
            ["tabindex"]: -1
          };
          const columnProps = (cellProperties === null || cellProperties === void 0 ? void 0 : cellProperties(...args)) || {};
          return Object.assign(Object.assign({}, wcagProps), columnProps);
        };
      });
    });
    this.addEventListener("beforesourceset", ({ detail }) => {
      revogrid.setAttribute("aria-rowcount", `${detail.source.length}`);
    });
    this.addEventListener("beforerowrender", ({ detail }) => {
      detail.node.$attrs$ = Object.assign(Object.assign({}, detail.node.$attrs$), { role: "row", ["aria-rowindex"]: detail.item.itemIndex });
    });
    this.addEventListener("afterfocus", async (e) => {
      if (e.defaultPrevented) {
        return;
      }
      const el = this.revogrid.querySelector(`revogr-data[type="${e.detail.rowType}"][col-type="${e.detail.colType}"] [data-rgrow="${e.detail.rowIndex}"][data-rgcol="${e.detail.colIndex}"]`);
      if (el instanceof HTMLElement) {
        el.focus();
      }
    });
  }
};
var PluginService = class {
  constructor() {
    this.internalPlugins = [];
  }
  /**
   * Get all plugins
   */
  get() {
    return [...this.internalPlugins];
  }
  /**
   * Add plugin to collection
   */
  add(plugin) {
    this.internalPlugins.push(plugin);
  }
  /**
   * Add user plugins and create
   */
  addUserPluginsAndCreate(element, plugins = [], prevPlugins, pluginData) {
    if (!pluginData) {
      return;
    }
    const pluginsToRemove = (prevPlugins === null || prevPlugins === void 0 ? void 0 : prevPlugins.filter((prevPlugin) => !plugins.some((userPlugin) => userPlugin === prevPlugin))) || [];
    pluginsToRemove.forEach((plugin) => {
      var _a, _b;
      const index = this.internalPlugins.findIndex((createdPlugin) => createdPlugin instanceof plugin);
      if (index !== -1) {
        (_b = (_a = this.internalPlugins[index]).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.internalPlugins.splice(index, 1);
      }
    });
    plugins === null || plugins === void 0 ? void 0 : plugins.forEach((userPlugin) => {
      const existingPlugin = this.internalPlugins.find((createdPlugin) => createdPlugin instanceof userPlugin);
      if (existingPlugin) {
        return;
      }
      this.add(new userPlugin(element, pluginData));
    });
  }
  /**
   * Get plugin by class
   */
  getByClass(pluginClass) {
    return this.internalPlugins.find((p) => p instanceof pluginClass);
  }
  /**
   * Remove plugin
   */
  remove(plugin) {
    var _a, _b;
    const index = this.internalPlugins.indexOf(plugin);
    if (index > -1) {
      (_b = (_a = this.internalPlugins[index]).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
      this.internalPlugins.splice(index, 1);
    }
  }
  /**
   * Remove all plugins
   */
  destroy() {
    this.internalPlugins.forEach((p) => {
      var _a;
      return (_a = p.destroy) === null || _a === void 0 ? void 0 : _a.call(p);
    });
    this.internalPlugins = [];
  }
};
var RTLPlugin = class extends BasePlugin {
  constructor(revogrid, providers) {
    super(revogrid, providers);
    this.isRTLEnabled = false;
    this.init();
  }
  init() {
    this.addEventListener("beforecolumnsset", (event) => {
      this.handleBeforeColumnsSet(event);
    });
    this.addEventListener("aftergridinit", () => {
      this.updateRTLState();
    });
    this.watch("rtl", (value) => {
      this.isRTLEnabled = value;
      this.emit("rtlstatechanged", { rtl: this.isRTLEnabled });
    }, { immediate: true });
  }
  /**
   * Handle the beforecolumnsset event to apply RTL transformation
   */
  handleBeforeColumnsSet(event) {
    if (!this.isRTLEnabled) {
      return;
    }
    const columnCollection = event.detail;
    const transformedColumns = this.applyRTLTransformationToCollection(columnCollection);
    event.detail.columns = transformedColumns.columns;
    event.detail.columnByProp = transformedColumns.columnByProp;
    event.detail.columnGrouping = transformedColumns.columnGrouping;
  }
  /**
   * Apply RTL transformation to the entire column collection
   */
  applyRTLTransformationToCollection(collection) {
    const transformedCollection = {
      columns: {
        rgCol: [],
        colPinStart: [],
        colPinEnd: []
      },
      columnByProp: Object.assign({}, collection.columnByProp),
      columnGrouping: {
        rgCol: [],
        colPinStart: [],
        colPinEnd: []
      },
      maxLevel: collection.maxLevel,
      sort: Object.assign({}, collection.sort)
    };
    Object.keys(collection.columns).forEach((type) => {
      const columnType = type;
      const columns = collection.columns[columnType];
      const reversedColumns = [...columns].reverse();
      transformedCollection.columns[columnType] = reversedColumns;
      transformedCollection.columnGrouping[columnType] = this.applyRTLTransformationToGroups(collection.columnGrouping[columnType], columns.length);
    });
    return transformedCollection;
  }
  /**
   * Apply RTL transformation to column groups
   */
  applyRTLTransformationToGroups(groups, totalColumns) {
    return groups.map((group) => {
      const reversedIndexes = group.indexes.map((index) => totalColumns - 1 - index).reverse();
      return Object.assign(Object.assign({}, group), { indexes: reversedIndexes });
    }).reverse();
  }
  /**
   * Update RTL state based on the grid's rtl property
   */
  updateRTLState() {
    const grid = this.revogrid;
    if (grid && typeof grid.rtl === "boolean") {
      this.isRTLEnabled = grid.rtl;
    }
  }
  /**
   * Get current RTL state
   */
  getRTLState() {
    return this.isRTLEnabled;
  }
  /**
   * Clean up the plugin
   */
  destroy() {
    super.destroy();
  }
};
var revoGridStyleCss = `revo-grid[theme=default],revo-grid:not([theme]){border:1px solid var(--revo-grid-header-border);font-size:12px}revo-grid[theme=default] .rowHeaders revogr-header,revo-grid:not([theme]) .rowHeaders revogr-header{box-shadow:-1px 0 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] revogr-header,revo-grid:not([theme]) revogr-header{text-align:center;line-height:30px;background-color:var(--revo-grid-header-bg)}revo-grid[theme=default] revogr-header .group-rgRow,revo-grid:not([theme]) revogr-header .group-rgRow{box-shadow:none}revo-grid[theme=default] revogr-header .group-rgRow .rgHeaderCell,revo-grid:not([theme]) revogr-header .group-rgRow .rgHeaderCell{box-shadow:-1px 0 0 0 var(--revo-grid-header-border), -1px 0 0 0 var(--revo-grid-header-border) inset, 0 -1px 0 0 var(--revo-grid-header-border), 0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] revogr-header .header-rgRow,revo-grid[theme=default] revogr-header .group-rgRow,revo-grid:not([theme]) revogr-header .header-rgRow,revo-grid:not([theme]) revogr-header .group-rgRow{text-transform:uppercase;font-size:12px;color:var(--revo-grid-header-color)}revo-grid[theme=default] revogr-header .header-rgRow,revo-grid:not([theme]) revogr-header .header-rgRow{height:30px;box-shadow:0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] revogr-header .rgHeaderCell,revo-grid:not([theme]) revogr-header .rgHeaderCell{box-shadow:-1px 0 0 0 var(--revo-grid-header-border) inset, 0 -1px 0 0 var(--revo-grid-header-border), 0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] .rowHeaders,revo-grid:not([theme]) .rowHeaders{background-color:var(--revo-grid-header-bg)}revo-grid[theme=default] .rowHeaders revogr-data .rgCell,revo-grid:not([theme]) .rowHeaders revogr-data .rgCell{color:var(--revo-grid-header-color)}revo-grid[theme=default] .rowHeaders revogr-data .rgCell:first-child,revo-grid:not([theme]) .rowHeaders revogr-data .rgCell:first-child{box-shadow:0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] .rowHeaders revogr-data .rgCell:not(:first-child),revo-grid:not([theme]) .rowHeaders revogr-data .rgCell:not(:first-child){box-shadow:0 -1px 0 0 var(--revo-grid-header-border) inset, 1px 0 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] .rowHeaders revogr-data .rgCell:last-child,revo-grid:not([theme]) .rowHeaders revogr-data .rgCell:last-child{border-right:1px solid var(--revo-grid-header-border)}revo-grid[theme=default] .rowHeaders revogr-data revogr-header,revo-grid:not([theme]) .rowHeaders revogr-data revogr-header{box-shadow:0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] revogr-viewport-scroll.colPinStart revogr-data .rgRow .rgCell:last-child,revo-grid:not([theme]) revogr-viewport-scroll.colPinStart revogr-data .rgRow .rgCell:last-child{box-shadow:0 -1px 0 0 var(--revo-grid-cell-border) inset, -1px 0 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] revogr-viewport-scroll.colPinStart .footer-wrapper revogr-data .rgRow:first-child .rgCell,revo-grid:not([theme]) revogr-viewport-scroll.colPinStart .footer-wrapper revogr-data .rgRow:first-child .rgCell{box-shadow:0 1px 0 0 var(--revo-grid-header-border) inset, -1px 0 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] revogr-viewport-scroll.colPinEnd,revo-grid[theme=default] revogr-viewport-scroll.colPinEnd revogr-header,revo-grid:not([theme]) revogr-viewport-scroll.colPinEnd,revo-grid:not([theme]) revogr-viewport-scroll.colPinEnd revogr-header{box-shadow:1px 0 0 var(--revo-grid-header-border) inset}revo-grid[theme=default] .footer-wrapper revogr-data .rgRow:first-child .rgCell,revo-grid:not([theme]) .footer-wrapper revogr-data .rgRow:first-child .rgCell{box-shadow:0 1px 0 0 var(--revo-grid-cell-border) inset, -1px 0 0 0 var(--revo-grid-cell-border) inset, 0 -1px 0 0 var(--revo-grid-cell-border) inset}revo-grid[theme=default] revogr-data,revo-grid:not([theme]) revogr-data{text-align:center}revo-grid[theme=default] revogr-data .revo-draggable,revo-grid:not([theme]) revogr-data .revo-draggable{float:left}revo-grid[theme=default] revogr-data .rgRow,revo-grid:not([theme]) revogr-data .rgRow{line-height:27px}revo-grid[theme=default] revogr-data .rgCell,revo-grid:not([theme]) revogr-data .rgCell{box-shadow:0 -1px 0 0 var(--revo-grid-cell-border) inset, -1px 0 0 0 var(--revo-grid-cell-border) inset}revo-grid[theme=material]{font-family:Nunito, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"}revo-grid[theme=material] revogr-header{line-height:50px;font-weight:600;text-align:left}revo-grid[theme=material] revogr-header .rgHeaderCell{padding:0 15px;text-overflow:ellipsis}revo-grid[theme=material] revogr-header .header-rgRow{height:50px}revo-grid[theme=material] revogr-data{text-align:left}revo-grid[theme=material] revogr-data .rgRow{line-height:42px}revo-grid[theme=material] revogr-data .rgCell{padding:0 15px}revo-grid[theme=darkMaterial]{font-family:Nunito, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"}revo-grid[theme=darkMaterial] revogr-header{line-height:50px;font-weight:600;text-align:left}revo-grid[theme=darkMaterial] revogr-header .rgHeaderCell{padding:0 15px;text-overflow:ellipsis}revo-grid[theme=darkMaterial] revogr-header .header-rgRow{height:50px}revo-grid[theme=darkMaterial] revogr-data{text-align:left}revo-grid[theme=darkMaterial] revogr-data .rgRow{line-height:42px}revo-grid[theme=darkMaterial] revogr-data .rgCell{padding:0 15px}revo-grid[theme=darkCompact]{font-family:Nunito, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"}revo-grid[theme=darkCompact] revogr-header{line-height:45px;font-weight:600;text-align:left}revo-grid[theme=darkCompact] revogr-header .rgHeaderCell{padding:0 15px;text-overflow:ellipsis}revo-grid[theme=darkCompact] revogr-header .header-rgRow{height:45px}revo-grid[theme=darkCompact] revogr-data{text-align:left}revo-grid[theme=darkCompact] revogr-data .rgRow{line-height:32px}revo-grid[theme=darkCompact] revogr-data .rgCell{padding:0 15px}revo-grid[theme=compact]{font-family:Nunito, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"}revo-grid[theme=compact] revogr-header{line-height:45px;font-weight:600;text-align:left}revo-grid[theme=compact] revogr-header .rgHeaderCell{padding:0 15px;text-overflow:ellipsis}revo-grid[theme=compact] revogr-header .header-rgRow{height:45px}revo-grid[theme=compact] revogr-data{text-align:left}revo-grid[theme=compact] revogr-data .rgRow{line-height:32px}revo-grid[theme=compact] revogr-data .rgCell{padding:0 15px}revo-grid[theme=compact] revo-dropdown .rv-dr-root{padding:0px 9px}revo-grid[dir=rtl] .viewports{flex-direction:row-reverse}revo-grid[dir=rtl] revogr-header .rgHeaderCell{text-align:right}revo-grid[dir=rtl] revogr-data .rgCell{text-align:right}revo-grid[dir=rtl] .rowHeaders revogr-data .rgCell{text-align:right}revo-grid[dir=rtl] revogr-filter-panel{direction:rtl}revo-grid[dir=rtl] revo-dropdown .rv-dr-root{text-align:right}revo-grid[dir=rtl] .drag-position{right:0;left:auto}revo-grid[dir=rtl] .drag-auto-scroll-y{right:0;left:auto}revo-grid[dir=rtl] .clipboard{right:0;left:auto}revo-grid[dir=rtl] .draggable{margin-left:-20px;margin-right:0;padding-right:20px;padding-left:5px}revo-grid[dir=rtl] .draggable .revo-alt-icon{right:5px;left:auto}revo-grid[dir=rtl] .focused-cell{border-right:2px solid var(--revo-grid-primary);border-left:none}revo-grid[dir=rtl] .selection-range{border-right:2px solid var(--revo-grid-primary);border-left:none}revo-grid[dir=rtl] .resize-handle{right:0;left:auto}revo-grid[dir=rtl] .sort-indicator{margin-left:0;margin-right:5px}revo-grid[dir=rtl] .filter-button{margin-left:0;margin-right:5px}revo-grid[dir=rtl] .group-expand{margin-right:0;margin-left:2px;padding-right:5px;padding-left:0}revo-grid[dir=rtl] .rgCell,revo-grid[dir=rtl] .rgHeaderCell{padding-left:5px;padding-right:5px}revo-grid[dir=rtl] revogr-edit{direction:rtl}revo-grid[dir=rtl] .rgHeaderCell{direction:rtl}revo-grid[dir=rtl][theme=material] revogr-header,revo-grid[dir=rtl][theme=darkMaterial] revogr-header{text-align:right}revo-grid[dir=rtl][theme=material] revogr-data,revo-grid[dir=rtl][theme=darkMaterial] revogr-data{text-align:right}revo-grid[dir=rtl][theme=default] .rowHeaders,revo-grid[dir=rtl]:not([theme]) .rowHeaders{background-color:var(--revo-grid-header-bg)}revo-grid[dir=rtl][theme=default] .rowHeaders revogr-data .rgCell,revo-grid[dir=rtl]:not([theme]) .rowHeaders revogr-data .rgCell{color:var(--revo-grid-header-color)}revo-grid[dir=rtl][theme=default] .rowHeaders revogr-data .rgCell:first-child,revo-grid[dir=rtl]:not([theme]) .rowHeaders revogr-data .rgCell:first-child{box-shadow:0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid[dir=rtl][theme=default] .rowHeaders revogr-data .rgCell:not(:first-child),revo-grid[dir=rtl]:not([theme]) .rowHeaders revogr-data .rgCell:not(:first-child){box-shadow:0 -1px 0 0 var(--revo-grid-header-border) inset, 1px 0 0 0 var(--revo-grid-header-border) inset}revo-grid[dir=rtl][theme=default] .rowHeaders revogr-data .rgCell:last-child,revo-grid[dir=rtl]:not([theme]) .rowHeaders revogr-data .rgCell:last-child{border-left:1px solid var(--revo-grid-header-border);border-right:none}revo-grid[dir=rtl][theme=default] .rowHeaders revogr-data revogr-header,revo-grid[dir=rtl]:not([theme]) .rowHeaders revogr-data revogr-header{box-shadow:0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid[dir=rtl][theme=default] revogr-header,revo-grid[dir=rtl]:not([theme]) revogr-header{text-align:right}revo-grid[dir=rtl][theme=default] revogr-data,revo-grid[dir=rtl]:not([theme]) revogr-data{text-align:right}revo-grid[dir=rtl][theme=compact] revogr-header,revo-grid[dir=rtl][theme=darkCompact] revogr-header{text-align:right}revo-grid[dir=rtl][theme=compact] revogr-data,revo-grid[dir=rtl][theme=darkCompact] revogr-data{text-align:right}.revo-drag-icon{width:11px;opacity:0.8}.revo-drag-icon::before{content:"::";display:inline-block}.revo-alt-icon{-webkit-mask-image:url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");width:11px;height:11px;background-size:cover;background-repeat:no-repeat}.arrow-down{position:absolute;right:5px;top:0}.arrow-down svg{width:8px;margin-top:5px;margin-left:5px;opacity:0.4}.cell-value-wrapper{margin-right:10px;overflow:hidden;text-overflow:ellipsis}revo-grid{--revo-grid-primary:#266ae8;--revo-grid-primary-transparent:rgba(38, 106, 232, 0.9);--revo-grid-background:#fff;--revo-grid-foreground:black;--revo-grid-divider:gray;--revo-grid-shadow:rgba(0, 0, 0, 0.15);--revo-grid-text:black;--revo-grid-border:rgba(0, 0, 0, 0.2);--revo-grid-filter-panel-bg:#fff;--revo-grid-filter-panel-border:#d9d9d9;--revo-grid-filter-panel-shadow:rgba(0, 0, 0, 0.15);--revo-grid-filter-panel-input-bg:#eaeaeb;--revo-grid-filter-panel-divider:#d9d9d9;--revo-grid-filter-panel-select-border:transparent;--revo-grid-filter-panel-select-border-hover:transparent;--revo-grid-header-bg:#f8f9fa;--revo-grid-header-color:#000;--revo-grid-header-border:#cecece;--revo-grid-cell-border:#e2e3e3;--revo-grid-focused-bg:rgba(233, 234, 237, 0.5);--revo-grid-row-hover:#f1f1f1;--revo-grid-row-headers-bg:#f7faff;--revo-grid-row-headers-color:#757a82;--revo-grid-cell-disabled-bg:rgba(0, 0, 0, 0.07);direction:ltr !important;display:flex !important;height:100%;min-height:300px;font-family:Helvetica, Arial, Sans-Serif, serif;font-size:14px;position:relative;color:var(--revo-grid-text);-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column;width:100%;height:100%}revo-grid[theme*=dark]{--revo-grid-background:#212529;--revo-grid-foreground:#fff;--revo-grid-text:rgba(255, 255, 255, 0.9);--revo-grid-divider:#505050;--revo-grid-border:rgba(255, 255, 255, 0.2);--revo-grid-filter-panel-bg:#212529;--revo-grid-filter-panel-border:#505050;--revo-grid-filter-panel-input-bg:#343a40;--revo-grid-filter-panel-divider:#505050;--revo-grid-header-bg:#343a40;--revo-grid-header-color:#fff;--revo-grid-header-border:#505050;--revo-grid-cell-border:#424242;--revo-grid-focused-bg:rgba(52, 58, 64, 0.5);--revo-grid-row-hover:rgba(80, 80, 80, 0.5);--revo-grid-row-headers-bg:rgba(52, 58, 64, 0.8);--revo-grid-row-headers-color:rgba(255, 255, 255, 0.8);--revo-grid-cell-disabled-bg:rgba(255, 255, 255, 0.07)}revo-grid revogr-header .header-rgRow.group{box-shadow:0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid revogr-header .header-rgRow:not(.group){box-shadow:0 -1px 0 0 var(--revo-grid-header-border), 0 -1px 0 0 var(--revo-grid-header-border) inset}revo-grid revogr-header .rgHeaderCell.sortable:hover{background-color:var(--revo-grid-row-hover)}revo-grid revogr-header .rgHeaderCell.focused-cell{background:var(--revo-grid-focused-bg)}revo-grid .footer-wrapper revogr-data{box-shadow:0 -1px 0 var(--revo-grid-cell-border)}revo-grid revogr-viewport-scroll.colPinStart{box-shadow:-1px 0 0 var(--revo-grid-cell-border) inset}revo-grid revogr-viewport-scroll.colPinEnd{box-shadow:-1px 0 0 var(--revo-grid-cell-border)}revo-grid revogr-data .rgRow{box-shadow:0 -1px 0 0 var(--revo-grid-cell-border) inset}revo-grid revogr-data .rgRow.focused-rgRow{background-color:var(--revo-grid-focused-bg)}revo-grid revogr-data .rgCell{color:var(--revo-grid-text)}revo-grid revogr-data .rgCell.disabled{background-color:var(--revo-grid-cell-disabled-bg)}revo-grid .attribution{position:absolute;bottom:0;left:0;right:0;z-index:1000;width:0;height:0;border-left:4px solid var(--revo-grid-primary-transparent);border-bottom:4px solid var(--revo-grid-primary-transparent);border-top:4px solid transparent;border-right:4px solid transparent;cursor:pointer}revo-grid .attribution .value{position:absolute;bottom:0;left:0;background-color:var(--revo-grid-background);padding:4px;border-radius:4px;box-shadow:0 1px 10px var(--revo-grid-border);white-space:nowrap;text-decoration:none;color:var(--revo-grid-text);letter-spacing:0.3px;font-size:11px;opacity:0;width:4px;overflow:hidden;transition:opacity 0.5s ease-in-out, width 0.3s ease-in-out}revo-grid .attribution:hover .value{width:63px;opacity:1}revo-grid.column-draggable.column-drag-start:hover,revo-grid.column-draggable.column-drag-start *:hover{cursor:grabbing}revo-grid .footer-wrapper,revo-grid .header-wrapper{width:100%}revo-grid .footer-wrapper revogr-data,revo-grid .header-wrapper revogr-data{z-index:3}revo-grid revo-dropdown{width:100%}revo-grid revo-dropdown .rv-dr-root{max-height:100%}revo-grid revo-dropdown.shrink label{opacity:0}revo-grid .viewports{max-width:100%;display:flex;flex-direction:row;align-items:flex-start;flex-grow:1}revo-grid .main-viewport{flex-grow:1;height:0;display:flex;justify-content:space-between;flex-direction:row}revo-grid .draggable{position:fixed;height:30px;line-height:30px;background:var(--revo-grid-background);border-radius:3px;display:block;z-index:100;margin-top:5px;margin-right:-20px;box-shadow:0 4px 20px 0 var(--revo-grid-shadow);padding-left:20px;padding-right:5px}revo-grid .draggable.hidden{display:none}revo-grid .draggable .revo-alt-icon{background-color:var(--revo-grid-foreground);position:absolute;left:5px;top:10px}revo-grid .draggable-wrapper.hidden{display:none}revo-grid .drag-position{position:absolute;left:0;right:0;height:1px;z-index:2;background:var(--revo-grid-divider);pointer-events:none}revo-grid .drag-position-y{position:absolute;top:0;left:0;bottom:0;width:1px;z-index:2;background:var(--revo-grid-divider);pointer-events:none}revo-grid .drag-auto-scroll-y{pointer-events:none;position:absolute;left:0;top:0;height:50px;width:1px}revo-grid .clipboard{position:absolute;left:0;top:0}revo-grid revogr-scroll-virtual{position:relative}revo-grid revogr-scroll-virtual.vertical,revo-grid revogr-scroll-virtual.horizontal{z-index:3}`;
var RevoGridComponent = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.contentsizechanged = createEvent(this, "contentsizechanged", 7);
    this.beforeedit = createEvent(this, "beforeedit", 7);
    this.beforerangeedit = createEvent(this, "beforerangeedit", 7);
    this.afteredit = createEvent(this, "afteredit", 7);
    this.beforeautofill = createEvent(this, "beforeautofill", 7);
    this.beforerange = createEvent(this, "beforerange", 7);
    this.afterfocus = createEvent(this, "afterfocus", 7);
    this.roworderchanged = createEvent(this, "roworderchanged", 7);
    this.beforesorting = createEvent(this, "beforesorting", 7);
    this.beforesourcesortingapply = createEvent(this, "beforesourcesortingapply", 7);
    this.beforesortingapply = createEvent(this, "beforesortingapply", 7);
    this.rowdragstart = createEvent(this, "rowdragstart", 7);
    this.headerclick = createEvent(this, "headerclick", 7);
    this.beforecellfocus = createEvent(this, "beforecellfocus", 7);
    this.beforefocuslost = createEvent(this, "beforefocuslost", 7);
    this.beforesourceset = createEvent(this, "beforesourceset", 7);
    this.beforeanysource = createEvent(this, "beforeanysource", 7);
    this.aftersourceset = createEvent(this, "aftersourceset", 7);
    this.afteranysource = createEvent(this, "afteranysource", 7);
    this.beforecolumnsset = createEvent(this, "beforecolumnsset", 7);
    this.beforecolumnapplied = createEvent(this, "beforecolumnapplied", 7);
    this.aftercolumnsset = createEvent(this, "aftercolumnsset", 7);
    this.beforefilterapply = createEvent(this, "beforefilterapply", 7);
    this.beforefiltertrimmed = createEvent(this, "beforefiltertrimmed", 7);
    this.beforetrimmed = createEvent(this, "beforetrimmed", 7);
    this.aftertrimmed = createEvent(this, "aftertrimmed", 7);
    this.viewportscroll = createEvent(this, "viewportscroll", 7);
    this.beforeexport = createEvent(this, "beforeexport", 7);
    this.beforeeditstart = createEvent(this, "beforeeditstart", 7);
    this.aftercolumnresize = createEvent(this, "aftercolumnresize", 7);
    this.beforerowdefinition = createEvent(this, "beforerowdefinition", 7);
    this.filterconfigchanged = createEvent(this, "filterconfigchanged", 7);
    this.sortingconfigchanged = createEvent(this, "sortingconfigchanged", 7);
    this.rowheaderschanged = createEvent(this, "rowheaderschanged", 7);
    this.beforegridrender = createEvent(this, "beforegridrender", 7);
    this.aftergridrender = createEvent(this, "aftergridrender", 7);
    this.aftergridinit = createEvent(this, "aftergridinit", 7);
    this.additionaldatachanged = createEvent(this, "additionaldatachanged", 7);
    this.afterthemechanged = createEvent(this, "afterthemechanged", 7);
    this.created = createEvent(this, "created", 7);
    this.frameSize = 1;
    this.rowSize = 0;
    this.colSize = 100;
    this.range = false;
    this.readonly = false;
    this.resize = false;
    this.canFocus = true;
    this.useClipboard = true;
    this.columns = [];
    this.source = [];
    this.pinnedTopSource = [];
    this.pinnedBottomSource = [];
    this.rowDefinitions = [];
    this.editors = {};
    this.applyOnClose = false;
    this.plugins = [];
    this.columnTypes = {};
    this.theme = "default";
    this.rowClass = "";
    this.autoSizeColumn = false;
    this.filter = false;
    this.canMoveColumns = false;
    this.trimmedRows = {};
    this.exporting = false;
    this.stretch = false;
    this.additionalData = {};
    this.disableVirtualX = false;
    this.disableVirtualY = false;
    this.hideAttribution = false;
    this.jobsBeforeRender = [];
    this.registerVNode = [];
    this.accessible = true;
    this.rtl = false;
    this.canDrag = true;
    this.extraElements = [];
    this.pluginService = new PluginService();
    this.viewport = null;
    this.isInited = false;
  }
  // #endregion
  // #region Methods
  /**
   * Refreshes data viewport.
   * Can be specific part as rgRow or pinned rgRow or 'all' by default.
   */
  async refresh(type = "all") {
    if (!this.dataProvider) {
      throw new Error("Not connected");
    }
    this.dataProvider.refresh(type);
  }
  /**
   * Refreshes data at specified cell.
   * Useful for performance optimization.
   * No viewport update will be triggered.
   *
   * @example
   * const grid = document.querySelector('revo-grid');
   * grid.setDataAt({ row: 0, col: 0, val: 'test' }); // refresh
   */
  async setDataAt({ row, col, colType = "rgCol", rowType = "rgRow", val, skipDataUpdate = false }) {
    var _a;
    if (this.dataProvider && this.columnProvider && !skipDataUpdate) {
      const columnProp = (_a = this.columnProvider.getColumn(col, colType)) === null || _a === void 0 ? void 0 : _a.prop;
      if (typeof columnProp !== "undefined") {
        this.dataProvider.setCellData({
          type: rowType,
          rowIndex: row,
          prop: columnProp,
          val
        }, false);
      }
    }
    const dataElement = this.element.querySelector(`revogr-data[type="${rowType}"][col-type="${colType}"]`);
    return dataElement === null || dataElement === void 0 ? void 0 : dataElement.updateCell({
      row,
      col
    });
  }
  /**
   * Scrolls viewport to specified row by index.
   */
  async scrollToRow(coordinate = 0) {
    if (!this.dimensionProvider) {
      throw new Error("Not connected");
    }
    const y = this.dimensionProvider.getViewPortPos({
      coordinate,
      dimension: "rgRow"
    });
    await this.scrollToCoordinate({ y });
  }
  /**
   * Scrolls viewport to specified column by index.
   */
  async scrollToColumnIndex(coordinate = 0) {
    if (!this.dimensionProvider) {
      throw new Error("Not connected");
    }
    const x = this.dimensionProvider.getViewPortPos({
      coordinate,
      dimension: "rgCol"
    });
    await this.scrollToCoordinate({ x });
  }
  /**
   * Scrolls viewport to specified column by prop
   */
  async scrollToColumnProp(prop, dimension = "rgCol") {
    if (!this.dimensionProvider || !this.columnProvider) {
      throw new Error("Not connected");
    }
    const coordinate = this.columnProvider.getColumnIndexByProp(prop, dimension);
    if (coordinate < 0) {
      return;
    }
    const x = this.dimensionProvider.getViewPortPos({
      coordinate,
      dimension
    });
    await this.scrollToCoordinate({ x });
  }
  /** Update columns */
  async updateColumns(cols) {
    var _a;
    (_a = this.columnProvider) === null || _a === void 0 ? void 0 : _a.updateColumns(cols);
  }
  /** Add trimmed by type */
  async addTrimmed(trimmed, trimmedType = "external", type = "rgRow") {
    if (!this.dataProvider) {
      throw new Error("Not connected");
    }
    const event = this.beforetrimmed.emit({
      trimmed,
      trimmedType,
      type
    });
    if (event.defaultPrevented) {
      return event;
    }
    this.dataProvider.setTrimmed({ [trimmedType]: event.detail.trimmed }, type);
    this.aftertrimmed.emit();
    return event;
  }
  /**  Scrolls view port to coordinate */
  async scrollToCoordinate(cell) {
    var _a;
    (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.scrollToCell(cell);
  }
  /**  Open editor for cell. */
  async setCellEdit(rgRow, prop, rowSource = "rgRow") {
    var _a;
    const rgCol = getColumnByProp(this.columns, prop);
    if (!rgCol) {
      return;
    }
    await timeout();
    const colGroup = rgCol.pin || "rgCol";
    if (!this.columnProvider) {
      throw new Error("Not connected");
    }
    (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.setEdit(rgRow, this.columnProvider.getColumnIndexByProp(prop, colGroup), colGroup, rowSource);
  }
  /**  Set focus range. */
  async setCellsFocus(cellStart = { x: 0, y: 0 }, cellEnd = { x: 0, y: 0 }, colType = "rgCol", rowType = "rgRow") {
    var _a;
    (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.setFocus(colType, rowType, cellStart, cellEnd);
  }
  /**  Get data from source */
  async getSource(type = "rgRow") {
    if (!this.dataProvider) {
      throw new Error("Not connected");
    }
    return this.dataProvider.stores[type].store.get("source");
  }
  /**
   * Get data from visible part of source
   * Trimmed/filtered rows will be excluded
   * @param type - type of source
   */
  async getVisibleSource(type = "rgRow") {
    if (!this.dataProvider) {
      throw new Error("Not connected");
    }
    return getVisibleSourceItem(this.dataProvider.stores[type].store);
  }
  /**
   * Provides access to rows internal store observer
   * Can be used for plugin support
   * @param type - type of source
   */
  async getSourceStore(type = "rgRow") {
    if (!this.dataProvider) {
      throw new Error("Not connected");
    }
    return this.dataProvider.stores[type].store;
  }
  /**
   * Provides access to column internal store observer
   * Can be used for plugin support
   * @param type - type of column
   */
  async getColumnStore(type = "rgCol") {
    if (!this.columnProvider) {
      throw new Error("Not connected");
    }
    return this.columnProvider.stores[type].store;
  }
  /**
   * Update column sorting
   * @param column - column prop and cellCompare
   * @param order - order to apply
   * @param additive - if false will replace current order
   *
   * later passed to SortingPlugin
   */
  async updateColumnSorting(column, order, additive) {
    this.sortingconfigchanged.emit({
      columns: [{
        prop: column.prop,
        order,
        cellCompare: column.cellCompare
      }],
      additive
    });
  }
  /**
   * Clears column sorting
   */
  async clearSorting() {
    this.sortingconfigchanged.emit({
      columns: []
    });
  }
  /**
   * Receive all columns in data source
   */
  async getColumns() {
    if (!this.columnProvider) {
      throw new Error("Not connected");
    }
    return this.columnProvider.getColumns();
  }
  /**
   * Clear current grid focus. Grid has no longer focus on it.
   */
  async clearFocus() {
    var _a, _b;
    const focused = (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.getFocused();
    const event = this.beforefocuslost.emit(focused);
    if (event.defaultPrevented) {
      return;
    }
    (_b = this.selectionStoreConnector) === null || _b === void 0 ? void 0 : _b.clearAll();
  }
  /**
   * Get all active plugins instances
   */
  async getPlugins() {
    return this.pluginService.get();
  }
  /**
   * Get the currently focused cell.
   */
  async getFocused() {
    var _a, _b;
    return (_b = (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.getFocused()) !== null && _b !== void 0 ? _b : null;
  }
  /**
   * Get size of content
   * Including all pinned data
   */
  async getContentSize() {
    var _a;
    if (!this.dimensionProvider) {
      throw new Error("Not connected");
    }
    return (_a = this.dimensionProvider) === null || _a === void 0 ? void 0 : _a.getFullSize();
  }
  /**
   * Get the currently selected Range.
   */
  async getSelectedRange() {
    var _a, _b;
    return (_b = (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.getSelectedRange()) !== null && _b !== void 0 ? _b : null;
  }
  /**
   * Refresh extra elements. Triggers re-rendering of extra elements and functions.
   * Part of extraElements and registerVNode methods.
   * Useful for plugins.
   */
  async refreshExtraElements() {
    var _a;
    (_a = this.extraService) === null || _a === void 0 ? void 0 : _a.refresh();
  }
  /**
   * Get all providers for grid
   * Useful for external grid integration
   */
  async getProviders() {
    return this.getPluginData();
  }
  mousedownHandle(event) {
    const screenX = getPropertyFromEvent(event, "screenX");
    const screenY = getPropertyFromEvent(event, "screenY");
    if (screenX === null || screenY === null) {
      return;
    }
    this.clickTrackForFocusClear = screenX + screenY;
  }
  /**
   * To keep your elements from losing focus use mouseup/touchend e.preventDefault();
   */
  async mouseupHandle(event) {
    var _a;
    const screenX = getPropertyFromEvent(event, "screenX");
    const screenY = getPropertyFromEvent(event, "screenY");
    if (screenX === null || screenY === null) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    const pos = screenX + screenY;
    if (Math.abs(((_a = this.clickTrackForFocusClear) !== null && _a !== void 0 ? _a : 0) - pos) > 10) {
      return;
    }
    const path = event.composedPath();
    if (!path.includes(this.element) && !(this.element.shadowRoot && path.includes(this.element.shadowRoot))) {
      await this.clearFocus();
    }
  }
  // #endregion
  // #region Listeners
  /** Drag events */
  onRowDragStarted(e) {
    var _a;
    const dragStart = this.rowdragstart.emit(e.detail);
    if (dragStart.defaultPrevented) {
      e.preventDefault();
      return;
    }
    (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.start(this.element, Object.assign(Object.assign({}, e.detail), dragStart.detail));
  }
  onRowDragEnd() {
    var _a;
    (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.end();
  }
  onRowOrderChange(e) {
    var _a;
    (_a = this.dataProvider) === null || _a === void 0 ? void 0 : _a.changeOrder(e.detail);
  }
  onRowDrag({ detail }) {
    var _a;
    (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.move(detail);
  }
  onRowMouseMove(e) {
    var _a;
    (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.moveTip(e.detail);
  }
  async onCellEdit(e) {
    var _a;
    const { defaultPrevented, detail } = this.beforeedit.emit(e.detail);
    await timeout();
    if (!defaultPrevented) {
      (_a = this.dataProvider) === null || _a === void 0 ? void 0 : _a.setCellData(detail);
      this.afteredit.emit(detail);
    }
  }
  onRangeEdit(e) {
    if (!this.dataProvider) {
      throw new Error("Not connected");
    }
    const { defaultPrevented, detail } = this.beforerangeedit.emit(e.detail);
    if (defaultPrevented) {
      e.preventDefault();
      return;
    }
    this.dataProvider.setRangeData(detail.data, detail.type);
    this.afteredit.emit(detail);
  }
  onRangeChanged(e) {
    const beforeange = this.beforerange.emit(e.detail);
    if (beforeange.defaultPrevented) {
      e.preventDefault();
    }
    const beforeFill = this.beforeautofill.emit(beforeange.detail);
    if (beforeFill.defaultPrevented) {
      e.preventDefault();
    }
  }
  onRowDropped(e) {
    const { defaultPrevented } = this.roworderchanged.emit(e.detail);
    if (defaultPrevented) {
      e.preventDefault();
    }
  }
  onHeaderClick(e) {
    const { defaultPrevented } = this.headerclick.emit(Object.assign(Object.assign({}, e.detail.column), { originalEvent: e.detail.originalEvent }));
    if (defaultPrevented) {
      e.preventDefault();
    }
  }
  onCellFocus(e) {
    const { defaultPrevented } = this.beforecellfocus.emit(e.detail);
    if (!this.canFocus || defaultPrevented) {
      e.preventDefault();
    }
  }
  // #endregion
  // #region Watchers
  columnTypesChanged() {
    this.columnChanged(this.columns);
  }
  columnChanged(newVal = [], _prevVal = void 0, __watchName = "columns", init = false) {
    if (!this.dimensionProvider || !this.columnProvider) {
      return;
    }
    const columnGather = getColumns(newVal, 0, this.columnTypes);
    const beforeSetEvent = this.beforecolumnsset.emit(columnGather);
    if (beforeSetEvent.defaultPrevented) {
      return;
    }
    this.dimensionProvider.applyNewColumns(beforeSetEvent.detail.columns, this.disableVirtualX, init);
    const beforeApplyEvent = this.beforecolumnapplied.emit(columnGather);
    if (beforeApplyEvent.defaultPrevented) {
      return;
    }
    const columns = this.columnProvider.setColumns(beforeApplyEvent.detail);
    this.aftercolumnsset.emit({
      columns,
      order: Object.entries(beforeApplyEvent.detail.sort).reduce((acc, [prop, column]) => {
        acc[prop] = column.order;
        return acc;
      }, {})
    });
  }
  disableVirtualXChanged(newVal = false, prevVal = false) {
    if (newVal === prevVal) {
      return;
    }
    this.columnChanged(this.columns);
  }
  rowSizeChanged(s) {
    if (!this.dimensionProvider) {
      return;
    }
    this.dimensionProvider.setSettings({ originItemSize: s }, "rgRow");
    this.rowDefChanged(this.rowDefinitions, this.rowDefinitions, "rowSize", true);
  }
  themeChanged(t, _, __ = "theme", init = false) {
    if (!this.dimensionProvider) {
      return;
    }
    this.themeService.register(t);
    this.dimensionProvider.setSettings({ originItemSize: this.themeService.rowSize }, "rgRow");
    this.dimensionProvider.setSettings({ originItemSize: this.colSize }, "rgCol");
    if (!init) {
      this.dimensionProvider.setSettings({ originItemSize: this.themeService.rowSize }, "rgRow");
      this.rowDefChanged(
        // for cases when some custom size present and not
        this.rowDefinitions,
        this.rowDefinitions,
        "theme",
        true
      );
    }
    this.afterthemechanged.emit(t);
  }
  dataSourceChanged(newVal = [], _, watchName) {
    if (!this.dataProvider) {
      return;
    }
    let type = "rgRow";
    switch (watchName) {
      case "pinnedBottomSource":
        type = "rowPinEnd";
        break;
      case "pinnedTopSource":
        type = "rowPinStart";
        break;
      case "source":
        type = "rgRow";
        const beforesourceset2 = this.beforesourceset.emit({
          type,
          source: newVal
        });
        newVal = beforesourceset2.detail.source;
        break;
    }
    const beforesourceset = this.beforeanysource.emit({
      type,
      source: newVal
    });
    const newSource = [...beforesourceset.detail.source];
    this.dataProvider.setData(newSource, type, this.disableVirtualY);
    if (watchName === "source") {
      this.aftersourceset.emit({
        type,
        source: newVal
      });
    }
    this.afteranysource.emit({
      type,
      source: newVal
    });
  }
  disableVirtualYChanged(newVal = false, prevVal = false) {
    if (newVal === prevVal) {
      return;
    }
    this.dataSourceChanged(this.source, this.source, "source");
  }
  rowDefChanged(after, before, _watchName, forceUpdate = true) {
    if (!this.dimensionProvider || !this.dataProvider) {
      return;
    }
    const { detail: { vals: newVal, oldVals: oldVal } } = this.beforerowdefinition.emit({
      vals: after,
      oldVals: before
    });
    const newRows = rowDefinitionByType(newVal);
    if (oldVal) {
      const remove = rowDefinitionRemoveByType(oldVal);
      for (const t in remove) {
        if (remove.hasOwnProperty(t)) {
          const type = t;
          const store = this.dataProvider.stores[type];
          const sourceLength = store.store.get("source").length;
          this.dimensionProvider.clearSize(type, sourceLength);
        }
      }
    }
    rowTypes.forEach((t) => {
      var _a;
      const newSizes = newRows[t];
      if (newSizes || forceUpdate) {
        (_a = this.dimensionProvider) === null || _a === void 0 ? void 0 : _a.setCustomSizes(t, (newSizes === null || newSizes === void 0 ? void 0 : newSizes.sizes) || {});
      }
    });
  }
  trimmedRowsChanged(newVal = {}) {
    this.addTrimmed(newVal);
  }
  /**
   * Grouping
   */
  groupingChanged(newVal = {}) {
    var _a;
    (_a = this.pluginService.getByClass(GroupingRowPlugin)) === null || _a === void 0 ? void 0 : _a.setGrouping(newVal || {});
  }
  /**
   * Stretch Plugin Apply
   */
  applyStretch(isStretch) {
    if (!this.dimensionProvider || !this.dataProvider || !this.columnProvider || !this.viewportProvider) {
      return;
    }
    if (isStretch === "false") {
      isStretch = false;
    }
    const pluginData = this.getPluginData();
    if (!pluginData) {
      return;
    }
    const stretch = this.pluginService.getByClass(StretchColumn);
    if (typeof isStretch === "boolean" && isStretch || isStretch === "true") {
      if (!stretch) {
        this.pluginService.add(new StretchColumn(this.element, pluginData));
      } else if (isStretchPlugin(stretch)) {
        stretch.applyStretch(this.columnProvider.getRawColumns());
      }
    } else if (stretch) {
      this.pluginService.remove(stretch);
    }
  }
  applyFilter(cfg) {
    this.filterconfigchanged.emit(cfg);
  }
  applySorting(cfg) {
    this.sortingconfigchanged.emit(cfg);
  }
  rowHeadersChange(rowHeaders) {
    this.rowheaderschanged.emit(rowHeaders);
  }
  /**
   * Register external VNodes
   */
  registerOutsideVNodes(elements = []) {
    this.extraElements = elements;
  }
  additionalDataChanged(data) {
    this.additionaldatachanged.emit(data);
  }
  /**
   * Watch for RTL changes and reapply column ordering
   */
  rtlChanged() {
    this.columnChanged(this.columns);
  }
  /**
   * User can add plugins via plugins property
   */
  pluginsChanged(plugins = [], prevPlugins) {
    this.pluginService.addUserPluginsAndCreate(this.element, plugins, prevPlugins, this.getPluginData());
  }
  // #endregion
  // #region Plugins
  setPlugins() {
    this.removePlugins();
    const pluginData = this.getPluginData();
    if (!pluginData) {
      return;
    }
    this.setCorePlugins(pluginData);
    this.pluginsChanged(this.plugins);
  }
  setCorePlugins(pluginData) {
    if (this.accessible) {
      this.pluginService.add(new WCAGPlugin(this.element, pluginData));
    }
    this.pluginService.add(new RTLPlugin(this.element, pluginData));
    if (this.autoSizeColumn) {
      this.pluginService.add(new AutoSizeColumnPlugin(this.element, pluginData, typeof this.autoSizeColumn === "object" ? this.autoSizeColumn : void 0));
    }
    if (this.filter) {
      this.pluginService.add(new FilterPlugin(this.element, pluginData, typeof this.filter === "object" ? this.filter : void 0));
    }
    if (this.exporting) {
      this.pluginService.add(new ExportFilePlugin(this.element, pluginData));
    }
    this.pluginService.add(new SortingPlugin(this.element, pluginData));
    this.pluginService.add(new GroupingRowPlugin(this.element, pluginData));
    if (this.canMoveColumns) {
      this.pluginService.add(new ColumnMovePlugin(this.element, pluginData));
    }
  }
  getPluginData() {
    if (!this.dimensionProvider || !this.dataProvider || !this.columnProvider || !this.viewportProvider || !this.selectionStoreConnector) {
      return;
    }
    const pluginData = {
      data: this.dataProvider,
      column: this.columnProvider,
      dimension: this.dimensionProvider,
      viewport: this.viewportProvider,
      selection: this.selectionStoreConnector,
      plugins: this.pluginService
    };
    return pluginData;
  }
  removePlugins() {
    this.pluginService.destroy();
  }
  // #endregion
  // if reconnect to dom we need to set up plugins
  connectedCallback() {
    if (this.isInited) {
      this.setPlugins();
    }
    this.created.emit();
  }
  /**
   * Called once just after the component is first connected to the DOM.
   * Since this method is only called once, it's a good place to load data asynchronously and to setup the state
   * without triggering extra re-renders.
   * A promise can be returned, that can be used to wait for the first render().
   */
  componentWillLoad() {
    var _a;
    this.viewportProvider = new ViewportProvider();
    this.themeService = new ThemeService({
      rowSize: this.rowSize
    });
    this.dimensionProvider = new DimensionProvider(this.viewportProvider, {
      realSizeChanged: (k) => this.contentsizechanged.emit(k)
    });
    this.columnProvider = new ColumnDataProvider();
    this.selectionStoreConnector = new SelectionStoreConnector();
    this.dataProvider = new DataProvider(this.dimensionProvider);
    this.registerOutsideVNodes(this.registerVNode);
    this.setPlugins();
    this.applyStretch(this.stretch);
    this.themeChanged(this.theme, void 0, void 0, true);
    this.columnChanged(this.columns, void 0, void 0, true);
    this.dataSourceChanged(this.source, void 0, "source");
    this.dataSourceChanged(this.pinnedTopSource, void 0, "pinnedTopSource");
    this.dataSourceChanged(this.pinnedBottomSource, void 0, "pinnedBottomSource");
    if (Object.keys((_a = this.trimmedRows) !== null && _a !== void 0 ? _a : {}).length > 0) {
      this.trimmedRowsChanged(this.trimmedRows);
    }
    this.rowDefChanged(this.rowDefinitions);
    if (this.grouping && Object.keys(this.grouping).length > 0) {
      this.groupingChanged(this.grouping);
    }
    this.scrollingService = new GridScrollingService((e) => {
      var _a2;
      (_a2 = this.dimensionProvider) === null || _a2 === void 0 ? void 0 : _a2.setViewPortCoordinate({
        coordinate: e.coordinate,
        type: e.dimension
      });
      this.viewportscroll.emit(e);
    });
    this.aftergridinit.emit();
    this.isInited = true;
  }
  componentWillRender() {
    const event = this.beforegridrender.emit();
    if (event.defaultPrevented) {
      return false;
    }
    return Promise.all(this.jobsBeforeRender);
  }
  componentDidRender() {
    this.aftergridrender.emit();
  }
  render() {
    if (!this.dimensionProvider || !this.dataProvider || !this.columnProvider || !this.viewportProvider || !this.selectionStoreConnector) {
      return;
    }
    const contentHeight = this.dimensionProvider.stores["rgRow"].store.get("realSize");
    this.viewport = new ViewportService({
      columnProvider: this.columnProvider,
      dataProvider: this.dataProvider,
      dimensionProvider: this.dimensionProvider,
      viewportProvider: this.viewportProvider,
      scrollingService: this.scrollingService,
      orderService: this.orderService,
      selectionStoreConnector: this.selectionStoreConnector,
      disableVirtualX: this.disableVirtualX,
      disableVirtualY: this.disableVirtualY,
      resize: (c) => this.aftercolumnresize.emit(c)
    }, contentHeight);
    const viewportSections = [];
    if (this.rowHeaders && this.viewport.columns.length) {
      const anyView = this.viewport.columns[0];
      viewportSections.push(h("revogr-row-headers", { additionalData: this.additionalData, height: contentHeight, rowClass: this.rowClass, resize: this.resize, dataPorts: anyView.dataPorts, headerProp: anyView.headerProp, jobsBeforeRender: this.jobsBeforeRender, rowHeaderColumn: typeof this.rowHeaders === "object" ? this.rowHeaders : void 0, onScrollview: ({ detail: e }) => this.scrollingService.proxyScroll(e, "headerRow"), onRef: ({ detail: e }) => this.scrollingService.registerElement(e, "headerRow") }));
    }
    const isMobile = isMobileDevice();
    const viewPortHtml = [];
    for (let view of this.viewport.columns) {
      const headerProperties = Object.assign(Object.assign({}, view.headerProp), { type: view.type, additionalData: this.additionalData, viewportCol: view.viewportCol, selectionStore: view.columnSelectionStore, canResize: this.resize, readonly: this.readonly, columnFilter: !!this.filter });
      const dataViews = [
        h("revogr-header", Object.assign({}, headerProperties, { slot: HEADER_SLOT }))
      ];
      view.dataPorts.forEach((data) => {
        const key = `${data.type}_${view.type}`;
        const dataView = h("revogr-overlay-selection", Object.assign({}, data, { canDrag: this.canDrag && data.canDrag, isMobileDevice: isMobile, onSelectall: () => {
          var _a;
          return (_a = this.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.selectAll();
        }, editors: this.editors, readonly: this.readonly, range: this.range, useClipboard: this.useClipboard, applyChangesOnClose: this.applyOnClose, additionalData: this.additionalData, slot: data.slot, onBeforenextvpfocus: (e) => {
          var _a;
          return (_a = this.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.beforeNextFocusCell(e.detail);
        }, onCanceledit: () => {
          var _a;
          return (_a = this.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.setEdit(false);
        }, onSetedit: ({ detail }) => {
          var _a;
          const event = this.beforeeditstart.emit(detail);
          if (!event.defaultPrevented) {
            (_a = this.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.setEdit(detail.val);
          }
        } }), h("revogr-data", Object.assign({}, data, { colType: view.type, key, readonly: this.readonly, range: this.range, rowClass: this.rowClass, rowSelectionStore: data.rowSelectionStore, additionalData: this.additionalData, jobsBeforeRender: this.jobsBeforeRender, slot: DATA_SLOT }), h("slot", { name: `data-${view.type}-${data.type}` })), h("revogr-temp-range", { selectionStore: data.selectionStore, dimensionRow: data.dimensionRow, dimensionCol: data.dimensionCol }), h("revogr-focus", { colData: data.colData, dataStore: data.dataStore, focusTemplate: this.focusTemplate, rowType: data.type, colType: view.type, selectionStore: data.selectionStore, dimensionRow: data.dimensionRow, dimensionCol: data.dimensionCol }, h("slot", { name: `focus-${view.type}-${data.type}` })));
        dataViews.push(dataView);
      });
      viewPortHtml.push(h("revogr-viewport-scroll", Object.assign({}, view.prop, { ref: (el) => this.scrollingService.registerElement(el, `${view.prop.key}`), onScrollviewport: (e) => this.scrollingService.proxyScroll(e.detail, `${view.prop.key}`), onScrollviewportsilent: (e) => this.scrollingService.scrollSilentService(e.detail, `${view.prop.key}`) }), dataViews));
    }
    viewportSections.push(viewPortHtml);
    const typeRow = "rgRow";
    const typeCol = "rgCol";
    const viewports = this.viewportProvider.stores;
    const dimensions = this.dimensionProvider.stores;
    const verticalScroll = h("revogr-scroll-virtual", { class: "vertical", dimension: typeRow, clientSize: viewports[typeRow].store.get("clientSize"), virtualSize: viewports[typeRow].store.get("virtualSize"), realSize: dimensions[typeRow].store.get("realSize"), ref: (el) => this.scrollingService.registerElement(el, "rowScroll"), onScrollvirtual: (e) => this.scrollingService.proxyScroll(e.detail) });
    const horizontalScroll = h("revogr-scroll-virtual", { class: "horizontal", dimension: typeCol, clientSize: viewports[typeCol].store.get("clientSize"), virtualSize: viewports[typeCol].store.get("virtualSize"), realSize: dimensions[typeCol].store.get("realSize"), ref: (el) => this.scrollingService.registerElement(el, "colScroll"), onScrollvirtual: (e) => this.scrollingService.proxyScroll(e.detail) });
    return h(Host, { dir: this.rtl ? "rtl" : "ltr" }, this.hideAttribution ? null : h("revogr-attribution", { class: "attribution" }), h("slot", { name: "header" }), h("div", { class: "main-viewport", onClick: (e) => {
      var _a;
      if (e.currentTarget === e.target) {
        (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.clearEdit();
      }
    } }, h("div", { class: "viewports" }, h("slot", { name: "viewport" }), viewportSections, verticalScroll, h(OrderRenderer, { ref: (e) => this.orderService = e }))), horizontalScroll, h("revogr-extra", { ref: (el) => this.extraService = el, nodes: this.extraElements }), h("slot", { name: "footer" }));
  }
  disconnectedCallback() {
    this.removePlugins();
  }
  get element() {
    return getElement(this);
  }
  static get watchers() {
    return {
      "columnTypes": ["columnTypesChanged"],
      "columns": ["columnChanged"],
      "disableVirtualX": ["disableVirtualXChanged"],
      "rowSize": ["rowSizeChanged"],
      "theme": ["themeChanged"],
      "source": ["dataSourceChanged"],
      "pinnedBottomSource": ["dataSourceChanged"],
      "pinnedTopSource": ["dataSourceChanged"],
      "disableVirtualY": ["disableVirtualYChanged"],
      "rowDefinitions": ["rowDefChanged"],
      "trimmedRows": ["trimmedRowsChanged"],
      "grouping": ["groupingChanged"],
      "stretch": ["applyStretch"],
      "filter": ["applyFilter"],
      "sorting": ["applySorting"],
      "rowHeaders": ["rowHeadersChange"],
      "registerVNode": ["registerOutsideVNodes"],
      "additionalData": ["additionalDataChanged"],
      "rtl": ["rtlChanged"],
      "plugins": ["pluginsChanged"]
    };
  }
};
RevoGridComponent.style = revoGridStyleCss;
export {
  RevoGridComponent as revo_grid
};
/*! Bundled license information:

@revolist/revogrid/dist/esm/column.drag.plugin-CmcURdIJ.js:
  (*!
   * Built by Revolist OU 
   *)

@revolist/revogrid/dist/esm/revo-grid.entry.js:
  (*!
   * Built by Revolist OU 
   *)
*/
//# sourceMappingURL=revo-grid.entry-XUTKGCOW.js.map
